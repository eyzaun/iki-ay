# Big-O Notation - Algoritma PerformansÄ±nÄ± Anlamak

## Big-O Nedir ve Neden Ã–nemli?

Big-O notation, algoritmalarÄ±n **ne kadar hÄ±zlÄ±** Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± Ã¶lÃ§mek iÃ§in kullanÄ±lan bir dil gibi dÃ¼ÅŸÃ¼nebilirsin. TÄ±pki araba hÄ±zÄ±nÄ± km/saat ile Ã¶lÃ§tÃ¼ÄŸÃ¼mÃ¼z gibi, algoritma hÄ±zÄ±nÄ± da Big-O ile Ã¶lÃ§eriz.

### GerÃ§ek Hayattan Ã–rnek
Diyelim ki telefonunda 1000 kiÅŸilik rehberin var:
- **SÄ±rayla arama:** A'dan Z'ye tek tek bakarsÄ±n â†’ En kÃ¶tÃ¼ 1000 iÅŸlem
- **HÄ±zlÄ± arama:** Ortadan baÅŸlayÄ±p yarÄ±ya bÃ¶l bÃ¶l ararsÄ±n â†’ En kÃ¶tÃ¼ 10 iÅŸlem

Ä°ÅŸte Big-O bu farkÄ± gÃ¶sterir! Birinci yÃ¶ntem O(n), ikincisi O(log n).

### Neden Ã–nemli?
1. **BÃ¼yÃ¼k veri:** 1000 eleman iÃ§in fark az, 1 milyon eleman iÃ§in Ã§ok bÃ¼yÃ¼k
2. **DoÄŸru algoritma seÃ§imi:** Hangi durumda hangi yÃ¶ntemi kullanacaÄŸÄ±nÄ± bilirsin
3. **Performans tahmini:** Kodun ne kadar sÃ¼receÄŸini Ã¶nceden tahmin edebilirsin

## Temel Big-O TÃ¼rleri (YavaÅŸtan HÄ±zlÄ±ya)

### 1. O(1) - Sabit Zaman âš¡
**Ne demek:** Veri ne kadar bÃ¼yÃ¼k olursa olsun, hep aynÄ± sÃ¼rede Ã§alÄ±ÅŸÄ±r.

**GerÃ§ek hayat Ã¶rneÄŸi:** TV kumandasÄ± ile kanal deÄŸiÅŸtirmek. Ä°ster 50 kanal ister 500 kanal olsun, tuÅŸa basÄ±nca hep aynÄ± sÃ¼rede deÄŸiÅŸir.

```csharp
// Array'de index ile eleman alma - Hep aynÄ± hÄ±zda!
public int GetElement(int[] array, int index)
{
    return array[index]; // Index 0 da olsa 1000 de olsa aynÄ± hÄ±z
}
```

### 2. O(log n) - Logaritmik Zaman ğŸ”
**Ne demek:** Veri 2 katÄ±na Ã§Ä±kÄ±nca sadece 1 adÄ±m daha atarsÄ±n.

**GerÃ§ek hayat Ã¶rneÄŸi:** SÃ¶zlÃ¼kte kelime aramak. 1000 sayfalÄ±k sÃ¶zlÃ¼kte kelime ararken ortadan baÅŸlar, yanlÄ±ÅŸ yarÄ±yÄ± atarsÄ±n. BÃ¶yle bÃ¶yle Ã§ok hÄ±zlÄ± bulursun.

```csharp
// Binary Search - Her adÄ±mda yarÄ±ya bÃ¶l
public int BinarySearch(int[] sortedArray, int target)
{
    int left = 0, right = sortedArray.Length - 1;
    
    while (left <= right)
    {
        int mid = (left + right) / 2;
        if (sortedArray[mid] == target) return mid;
        
        if (sortedArray[mid] < target)
            left = mid + 1;  // Sol yarÄ±yÄ± at
        else
            right = mid - 1; // SaÄŸ yarÄ±yÄ± at
    }
    return -1;
}
```

### 3. O(n) - DoÄŸrusal Zaman ğŸ“ˆ
**Ne demek:** Veri 2 katÄ±na Ã§Ä±kÄ±nca sÃ¼re de 2 katÄ±na Ã§Ä±kar.

**GerÃ§ek hayat Ã¶rneÄŸi:** Kitap okumak. 100 sayfa okursan 1 saat, 200 sayfa okursan 2 saat.

```csharp
// Linear Search - Tek tek hepsine bak
public int LinearSearch(int[] array, int target)
{
    for (int i = 0; i < array.Length; i++)
    {
        if (array[i] == target) return i;
    }
    return -1; // En kÃ¶tÃ¼ durumda tÃ¼m elemanlarÄ± gezer
}
```

### 4. O(nÂ²) - Karesel Zaman ğŸŒ
**Ne demek:** Veri 2 katÄ±na Ã§Ä±kÄ±nca sÃ¼re 4 katÄ±na Ã§Ä±kar!

**GerÃ§ek hayat Ã¶rneÄŸi:** SÄ±nÄ±ftaki herkesin herkesle tokalaÅŸmasÄ±. 10 kiÅŸi varsa 100 tokalaÅŸma, 20 kiÅŸi varsa 400 tokalaÅŸma.

```csharp
// Bubble Sort - Ä°Ã§ iÃ§e dÃ¶ngÃ¼
public void BubbleSort(int[] array)
{
    for (int i = 0; i < array.Length; i++)        // DÄ±ÅŸ dÃ¶ngÃ¼
    {
        for (int j = 0; j < array.Length - 1; j++) // Ä°Ã§ dÃ¶ngÃ¼
        {
            if (array[j] > array[j + 1])
            {
                // Swap
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
```

## Pratik Ã–rnekler ve KarÅŸÄ±laÅŸtÄ±rma

### Problem: Array'de en bÃ¼yÃ¼k sayÄ±yÄ± bul

```csharp
// Tek dÃ¶ngÃ¼ ile - O(n)
public int FindMax(int[] array)
{
    int max = array[0];
    for (int i = 1; i < array.Length; i++) // Her elemanÄ± bir kez kontrol et
    {
        if (array[i] > max)
            max = array[i];
    }
    return max;
}
```

### Problem: Ä°ki sayÄ±nÄ±n toplamÄ± target'a eÅŸit mi?

```csharp
// YavaÅŸ yÃ¶ntem - O(nÂ²)
public bool HasPairSumSlow(int[] array, int target)
{
    for (int i = 0; i < array.Length; i++)
    {
        for (int j = i + 1; j < array.Length; j++) // Her ikiliye bak
        {
            if (array[i] + array[j] == target)
                return true;
        }
    }
    return false;
}

// HÄ±zlÄ± yÃ¶ntem - O(n)
public bool HasPairSumFast(int[] array, int target)
{
    HashSet<int> seen = new HashSet<int>();
    
    foreach (int num in array)
    {
        int complement = target - num;
        if (seen.Contains(complement)) // O(1) arama
            return true;
        seen.Add(num);
    }
    return false;
}
```

## Hangi Durumda Hangi HÄ±z Beklenir?

- **O(1):** Hashtable'da arama, array'de index ile eriÅŸim
- **O(log n):** Binary search, balanced tree'lerde arama
- **O(n):** Linear search, array'i bir kez gezmek
- **O(n log n):** Ä°yi sÄ±ralama algoritmalarÄ± (Merge Sort, Quick Sort)
- **O(nÂ²):** Basit sÄ±ralama algoritmalarÄ± (Bubble Sort, Selection Sort)

## Ã–nemli PÃ¼f NoktalarÄ±

1. **BÃ¼yÃ¼k veri iÃ§in Ã¶nemli:** 10 eleman varsa fark yok, 1 milyon varsa Ã§ok fark var
2. **Sabitler ihmal edilir:** O(2n) = O(n), O(n + 100) = O(n)
3. **En kÃ¶tÃ¼ durum:** Big-O genellikle worst-case'i gÃ¶sterir
4. **En bÃ¼yÃ¼k terim:** O(nÂ² + n) = O(nÂ²), Ã§Ã¼nkÃ¼ nÂ² Ã§ok daha bÃ¼yÃ¼k

## Algoritma SeÃ§erken Kendine Sor:

- Verimin ne kadar bÃ¼yÃ¼k olacak?
- KaÃ§ kez bu iÅŸlemi yapacaksÄ±n?
- HafÄ±za da Ã¶nemli mi yoksa sadece hÄ±z mÄ±?

Bu sorulara gÃ¶re doÄŸru algoritma karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± seÃ§ebilirsin!