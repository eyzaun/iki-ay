# Queue (Kuyruk) - FIFO Veri YapÄ±sÄ±

## Queue Nedir? FIFO Prensibi

Queue, **market kuyruÄŸu** gibi dÃ¼ÅŸÃ¼n. Ä°lk gelen ilk hizmet alÄ±r - **First In, First Out (FIFO)** prensibiyle Ã§alÄ±ÅŸÄ±r. Stack'in tam tersi!

### GerÃ§ek Hayattan Queue Ã–rnekleri:
1. **Market kuyruÄŸu:** Ä°lk gelen Ã¶nce kassaya gider
2. **YazÄ±cÄ± kuyruÄŸu:** Ä°lk gÃ¶nderilen dÃ¶kÃ¼man Ã¶nce Ã§Ä±kar
3. **Trafik Ä±ÅŸÄ±ÄŸÄ±:** Ã–nde duran araba Ã¶nce geÃ§er
4. **Telefon mÃ¼ÅŸteri hizmetleri:** Ä°lk arayan Ã¶nce baÄŸlanÄ±r

### Stack vs Queue - Temel Fark:
- **Stack:** Son giren ilk Ã§Ä±kar (tabak yÄ±ÄŸÄ±nÄ±) ğŸ¥
- **Queue:** Ä°lk giren ilk Ã§Ä±kar (kuyruk) ğŸš¶â€â™‚ï¸ğŸš¶â€â™€ï¸ğŸš¶â€â™‚ï¸

## Queue'nun Temel Ä°ÅŸlemleri

Queue'da iki ana iÅŸlem var:

### 1. Enqueue - Arkaya Ekleme O(1) âš¡
```csharp
// KuyruÄŸun arkasÄ±na eleman ekle
queue.Enqueue(element);
```

### 2. Dequeue - Ã–nden Alma O(1) âš¡  
```csharp
// KuyruÄŸun Ã¶nÃ¼ndeki elemanÄ± al ve kaldÄ±r
element = queue.Dequeue();
```

### 3. Front/Peek - Ã–ndekine Bakma O(1) âš¡
```csharp
// Ã–nÃ¼ndeki elemanÄ± gÃ¶ster ama kaldÄ±rma
element = queue.Peek();
```

### 4. IsEmpty - BoÅŸ mu KontrolÃ¼ O(1) âš¡
```csharp
// Queue boÅŸ mu?
bool isEmpty = queue.Count == 0;
```

## Array ile Queue Implementation

```csharp
public class MyQueue
{
    private int[] items;
    private int front;      // KuyruÄŸun Ã¶nÃ¼
    private int rear;       // KuyruÄŸun arkasÄ±
    private int count;      // Eleman sayÄ±sÄ±
    private int capacity;
    
    public MyQueue(int size)
    {
        items = new int[size];
        capacity = size;
        front = 0;
        rear = -1;
        count = 0;
    }
    
    // Enqueue - O(1)
    public void Enqueue(int item)
    {
        if (count >= capacity)
            throw new InvalidOperationException("Queue dolu!");
        
        rear = (rear + 1) % capacity;  // Circular movement
        items[rear] = item;
        count++;
    }
    
    // Dequeue - O(1)
    public int Dequeue()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boÅŸ!");
        
        int item = items[front];
        front = (front + 1) % capacity;  // Circular movement
        count--;
        return item;
    }
    
    // Peek - O(1)
    public int Peek()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boÅŸ!");
        
        return items[front];
    }
    
    public bool IsEmpty() => count == 0;
    public int Count => count;
}
```

## Circular Queue - AkÄ±llÄ± Ã‡Ã¶zÃ¼m

Normal array queue'da problem: elemanlar Ã§Ä±ktÄ±kÃ§a baÅŸta boÅŸ yer kalÄ±r ama kullanamayÄ±z. **Circular Queue** bu sorunu Ã§Ã¶zer:

```
Normal Queue:
[_][_][C][D][E]    â† Front=2, Rear=4, BoÅŸ alan kullanÄ±lamaz
 â†‘  â†‘   
boÅŸ boÅŸ

Circular Queue:
[F][G][C][D][E]    â† Front=2, Rear=1 (wrap around)
 â†‘     â†‘
rear  front
```

## LinkedList ile Queue Implementation

```csharp
public class LinkedQueue
{
    private ListNode front;   // KuyruÄŸun Ã¶nÃ¼
    private ListNode rear;    // KuyruÄŸun arkasÄ±
    private int count;
    
    private class ListNode
    {
        public int Data { get; set; }
        public ListNode Next { get; set; }
        
        public ListNode(int data)
        {
            Data = data;
            Next = null;
        }
    }
    
    public LinkedQueue()
    {
        front = null;
        rear = null;
        count = 0;
    }
    
    // Enqueue - Arkaya ekleme O(1)
    public void Enqueue(int item)
    {
        ListNode newNode = new ListNode(item);
        
        if (rear == null)  // Ä°lk eleman
        {
            front = rear = newNode;
        }
        else
        {
            rear.Next = newNode;  // Son node'un next'i yeni node
            rear = newNode;       // Rear'Ä± gÃ¼ncelle
        }
        count++;
    }
    
    // Dequeue - Ã–nden alma O(1)
    public int Dequeue()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boÅŸ!");
        
        int data = front.Data;
        front = front.Next;
        
        if (front == null)  // Son eleman Ã§Ä±karÄ±ldÄ±
            rear = null;
        
        count--;
        return data;
    }
    
    public int Peek()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boÅŸ!");
        
        return front.Data;
    }
    
    public bool IsEmpty() => front == null;
    public int Count => count;
}
```

## Queue Ä°ÅŸlemlerinin GÃ¶rsel AÃ§Ä±klamasÄ±

```
Queue Durumu:    [BoÅŸ]

Enqueue(10):     [10]
                 â†‘   â†‘
               front rear

Enqueue(20):     [10] â†’ [20]
                 â†‘      â†‘
               front   rear

Enqueue(30):     [10] â†’ [20] â†’ [30]
                 â†‘             â†‘
               front          rear

Dequeue():       [20] â†’ [30]      (10 dÃ¶ndÃ¼rÃ¼ldÃ¼)
                 â†‘      â†‘
               front   rear

Peek():          [20] â†’ [30]      (20 gÃ¶sterildi)
                 â†‘      â†‘
               front   rear
```

## .NET'te Queue<T> KullanÄ±mÄ±

```csharp
// .NET'in hazÄ±r Queue'u
Queue<int> queue = new Queue<int>();

// Enqueue - ekleme
queue.Enqueue(10);
queue.Enqueue(20);
queue.Enqueue(30);

Console.WriteLine($"Count: {queue.Count}"); // 3

// Peek - Ã¶nÃ¼ndekine bakma
int front = queue.Peek(); // 10 (kaldÄ±rÄ±lmaz)

// Dequeue - Ã¶nden alma
int dequeued = queue.Dequeue(); // 10 (kaldÄ±rÄ±lÄ±r)

// Contains - arama
bool has20 = queue.Contains(20); // true

// ToArray - diziye Ã§evirme
int[] array = queue.ToArray(); // [20, 30] (sÄ±ra korunur)

// Clear - temizleme
queue.Clear();
```

## Queue'nun GerÃ§ek Hayat UygulamalarÄ±

### 1. BFS (Breadth-First Search) - Graf Gezinme
```csharp
public void BFS(GraphNode startNode)
{
    Queue<GraphNode> queue = new Queue<GraphNode>();
    HashSet<GraphNode> visited = new HashSet<GraphNode>();
    
    queue.Enqueue(startNode);
    visited.Add(startNode);
    
    while (queue.Count > 0)
    {
        GraphNode current = queue.Dequeue();
        Console.WriteLine($"Ziyaret: {current.Value}");
        
        // KomÅŸularÄ± kuyruÄŸa ekle
        foreach (GraphNode neighbor in current.Neighbors)
        {
            if (!visited.Contains(neighbor))
            {
                queue.Enqueue(neighbor);
                visited.Add(neighbor);
            }
        }
    }
}
```

### 2. YazÄ±cÄ± KuyruÄŸu (Print Queue)
```csharp
public class PrintQueue
{
    private Queue<PrintJob> jobs = new Queue<PrintJob>();
    
    public void AddJob(string document, int pages)
    {
        PrintJob job = new PrintJob(document, pages);
        jobs.Enqueue(job);
        Console.WriteLine($"Ä°ÅŸ eklendi: {document}");
    }
    
    public void ProcessNextJob()
    {
        if (jobs.Count > 0)
        {
            PrintJob job = jobs.Dequeue();
            Console.WriteLine($"YazdÄ±rÄ±lÄ±yor: {job.Document}");
            // YazdÄ±rma iÅŸlemi...
        }
        else
        {
            Console.WriteLine("Kuyruk boÅŸ!");
        }
    }
    
    public int JobsWaiting => jobs.Count;
}
```

### 3. Hot Potato Game (Josephus Problem)
```csharp
public string HotPotato(string[] names, int num)
{
    Queue<string> queue = new Queue<string>();
    
    // Herkesi kuyruÄŸa ekle
    foreach (string name in names)
    {
        queue.Enqueue(name);
    }
    
    while (queue.Count > 1)
    {
        // num kadar dÃ¶ndÃ¼r
        for (int i = 0; i < num; i++)
        {
            string person = queue.Dequeue();
            queue.Enqueue(person);  // Arkaya geri ekle
        }
        
        // Son kiÅŸiyi eleme
        string eliminated = queue.Dequeue();
        Console.WriteLine($"Elenen: {eliminated}");
    }
    
    return queue.Dequeue(); // Son kalan
}

// KullanÄ±m: HotPotato(["Ali", "AyÅŸe", "Mehmet", "Fatma"], 3)
```

### 4. Multi-level Queue (Ã–ncelik SÄ±rasÄ±)
```csharp
public class PriorityQueue
{
    private Queue<Task> highPriority = new Queue<Task>();
    private Queue<Task> normalPriority = new Queue<Task>();
    private Queue<Task> lowPriority = new Queue<Task>();
    
    public void AddTask(Task task)
    {
        switch (task.Priority)
        {
            case Priority.High:
                highPriority.Enqueue(task);
                break;
            case Priority.Normal:
                normalPriority.Enqueue(task);
                break;
            case Priority.Low:
                lowPriority.Enqueue(task);
                break;
        }
    }
    
    public Task GetNextTask()
    {
        // YÃ¼ksek Ã¶ncelik â†’ Normal â†’ DÃ¼ÅŸÃ¼k sÄ±rasÄ±yla
        if (highPriority.Count > 0)
            return highPriority.Dequeue();
        else if (normalPriority.Count > 0)
            return normalPriority.Dequeue();
        else if (lowPriority.Count > 0)
            return lowPriority.Dequeue();
        else
            return null;
    }
}
```

## Queue TÃ¼rleri

### 1. Simple Queue
- Standart FIFO davranÄ±ÅŸ
- En yaygÄ±n kullanÄ±lan tÃ¼r

### 2. Circular Queue  
- Array sonuna gelince baÅŸa dÃ¶ner
- Bellek efficient

### 3. Priority Queue
- ElemanlarÄ±n Ã¶ncelik sÄ±rasÄ± var
- Heap veri yapÄ±sÄ± ile implement edilir

### 4. Deque (Double-ended Queue)
- Her iki ucundan da ekleme/Ã§Ä±karma
- Hem Stack hem Queue gibi davranabilir

## Queue vs Stack - DetaylÄ± KarÅŸÄ±laÅŸtÄ±rma

| Ã–zellik | Queue (FIFO) | Stack (LIFO) |
|---------|-------------|-------------|
| **Ekleme** | Arkaya (rear) | Ãœste (top) |
| **Ã‡Ä±karma** | Ã–nden (front) | Ãœstten (top) |
| **KullanÄ±m** | SÄ±ra takip | Geri alma |
| **Algoritma** | BFS | DFS |
| **GerÃ§ek hayat** | Market kuyruÄŸu | Tabak yÄ±ÄŸÄ±nÄ± |

## Queue Ne Zaman KullanÄ±lÄ±r?

### âœ… Queue Kullan EÄŸer:
- **FIFO** davranÄ±ÅŸ gerekiyorsa
- **BFS** algoritmasÄ± uyguluyorsan
- **Task scheduling** yapÄ±yorsan
- **Buffering** gerekiyorsa (IO operations)
- **Level-order traversal** (tree'lerde)

### âŒ Queue Kullanma EÄŸer:
- **LIFO** davranÄ±ÅŸ istiyorsan (Stack kullan)
- **Random access** gerekiyorsan (Array kullan)
- **Priority** Ã¶nemliyse (PriorityQueue kullan)
- **Arama** operasyonu Ã§ok Ã¶nemliyse

## Ä°leri Seviye: Deque (Double-ended Queue)

```csharp
// .NET'te Deque yok, ama LinkedList ile simÃ¼le edebiliriz
LinkedList<int> deque = new LinkedList<int>();

// BaÅŸa ekleme/Ã§Ä±karma (Stack gibi)
deque.AddFirst(10);
int front = deque.First.Value;
deque.RemoveFirst();

// Sona ekleme/Ã§Ä±karma (Queue gibi)  
deque.AddLast(20);
int back = deque.Last.Value;
deque.RemoveLast();
```

Queue, sistemlerin adil ve dÃ¼zenli Ã§alÄ±ÅŸmasÄ± iÃ§in kritik bir veri yapÄ±sÄ±. Her yerde karÅŸÄ±laÅŸtÄ±ÄŸÄ±n ama fark etmediÄŸin bir kavram!