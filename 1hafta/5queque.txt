# Queue (Kuyruk) - FIFO Veri Yapısı

## Queue Nedir? FIFO Prensibi

Queue, **market kuyruğu** gibi düşün. İlk gelen ilk hizmet alır - **First In, First Out (FIFO)** prensibiyle çalışır. Stack'in tam tersi!

### Gerçek Hayattan Queue Örnekleri:
1. **Market kuyruğu:** İlk gelen önce kassaya gider
2. **Yazıcı kuyruğu:** İlk gönderilen döküman önce çıkar
3. **Trafik ışığı:** Önde duran araba önce geçer
4. **Telefon müşteri hizmetleri:** İlk arayan önce bağlanır

### Stack vs Queue - Temel Fark:
- **Stack:** Son giren ilk çıkar (tabak yığını) 🥞
- **Queue:** İlk giren ilk çıkar (kuyruk) 🚶‍♂️🚶‍♀️🚶‍♂️

## Queue'nun Temel İşlemleri

Queue'da iki ana işlem var:

### 1. Enqueue - Arkaya Ekleme O(1) ⚡
```csharp
// Kuyruğun arkasına eleman ekle
queue.Enqueue(element);
```

### 2. Dequeue - Önden Alma O(1) ⚡  
```csharp
// Kuyruğun önündeki elemanı al ve kaldır
element = queue.Dequeue();
```

### 3. Front/Peek - Öndekine Bakma O(1) ⚡
```csharp
// Önündeki elemanı göster ama kaldırma
element = queue.Peek();
```

### 4. IsEmpty - Boş mu Kontrolü O(1) ⚡
```csharp
// Queue boş mu?
bool isEmpty = queue.Count == 0;
```

## Array ile Queue Implementation

```csharp
public class MyQueue
{
    private int[] items;
    private int front;      // Kuyruğun önü
    private int rear;       // Kuyruğun arkası
    private int count;      // Eleman sayısı
    private int capacity;
    
    public MyQueue(int size)
    {
        items = new int[size];
        capacity = size;
        front = 0;
        rear = -1;
        count = 0;
    }
    
    // Enqueue - O(1)
    public void Enqueue(int item)
    {
        if (count >= capacity)
            throw new InvalidOperationException("Queue dolu!");
        
        rear = (rear + 1) % capacity;  // Circular movement
        items[rear] = item;
        count++;
    }
    
    // Dequeue - O(1)
    public int Dequeue()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boş!");
        
        int item = items[front];
        front = (front + 1) % capacity;  // Circular movement
        count--;
        return item;
    }
    
    // Peek - O(1)
    public int Peek()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boş!");
        
        return items[front];
    }
    
    public bool IsEmpty() => count == 0;
    public int Count => count;
}
```

## Circular Queue - Akıllı Çözüm

Normal array queue'da problem: elemanlar çıktıkça başta boş yer kalır ama kullanamayız. **Circular Queue** bu sorunu çözer:

```
Normal Queue:
[_][_][C][D][E]    ← Front=2, Rear=4, Boş alan kullanılamaz
 ↑  ↑   
boş boş

Circular Queue:
[F][G][C][D][E]    ← Front=2, Rear=1 (wrap around)
 ↑     ↑
rear  front
```

## LinkedList ile Queue Implementation

```csharp
public class LinkedQueue
{
    private ListNode front;   // Kuyruğun önü
    private ListNode rear;    // Kuyruğun arkası
    private int count;
    
    private class ListNode
    {
        public int Data { get; set; }
        public ListNode Next { get; set; }
        
        public ListNode(int data)
        {
            Data = data;
            Next = null;
        }
    }
    
    public LinkedQueue()
    {
        front = null;
        rear = null;
        count = 0;
    }
    
    // Enqueue - Arkaya ekleme O(1)
    public void Enqueue(int item)
    {
        ListNode newNode = new ListNode(item);
        
        if (rear == null)  // İlk eleman
        {
            front = rear = newNode;
        }
        else
        {
            rear.Next = newNode;  // Son node'un next'i yeni node
            rear = newNode;       // Rear'ı güncelle
        }
        count++;
    }
    
    // Dequeue - Önden alma O(1)
    public int Dequeue()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boş!");
        
        int data = front.Data;
        front = front.Next;
        
        if (front == null)  // Son eleman çıkarıldı
            rear = null;
        
        count--;
        return data;
    }
    
    public int Peek()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Queue boş!");
        
        return front.Data;
    }
    
    public bool IsEmpty() => front == null;
    public int Count => count;
}
```

## Queue İşlemlerinin Görsel Açıklaması

```
Queue Durumu:    [Boş]

Enqueue(10):     [10]
                 ↑   ↑
               front rear

Enqueue(20):     [10] → [20]
                 ↑      ↑
               front   rear

Enqueue(30):     [10] → [20] → [30]
                 ↑             ↑
               front          rear

Dequeue():       [20] → [30]      (10 döndürüldü)
                 ↑      ↑
               front   rear

Peek():          [20] → [30]      (20 gösterildi)
                 ↑      ↑
               front   rear
```

## .NET'te Queue<T> Kullanımı

```csharp
// .NET'in hazır Queue'u
Queue<int> queue = new Queue<int>();

// Enqueue - ekleme
queue.Enqueue(10);
queue.Enqueue(20);
queue.Enqueue(30);

Console.WriteLine($"Count: {queue.Count}"); // 3

// Peek - önündekine bakma
int front = queue.Peek(); // 10 (kaldırılmaz)

// Dequeue - önden alma
int dequeued = queue.Dequeue(); // 10 (kaldırılır)

// Contains - arama
bool has20 = queue.Contains(20); // true

// ToArray - diziye çevirme
int[] array = queue.ToArray(); // [20, 30] (sıra korunur)

// Clear - temizleme
queue.Clear();
```

## Queue'nun Gerçek Hayat Uygulamaları

### 1. BFS (Breadth-First Search) - Graf Gezinme
```csharp
public void BFS(GraphNode startNode)
{
    Queue<GraphNode> queue = new Queue<GraphNode>();
    HashSet<GraphNode> visited = new HashSet<GraphNode>();
    
    queue.Enqueue(startNode);
    visited.Add(startNode);
    
    while (queue.Count > 0)
    {
        GraphNode current = queue.Dequeue();
        Console.WriteLine($"Ziyaret: {current.Value}");
        
        // Komşuları kuyruğa ekle
        foreach (GraphNode neighbor in current.Neighbors)
        {
            if (!visited.Contains(neighbor))
            {
                queue.Enqueue(neighbor);
                visited.Add(neighbor);
            }
        }
    }
}
```

### 2. Yazıcı Kuyruğu (Print Queue)
```csharp
public class PrintQueue
{
    private Queue<PrintJob> jobs = new Queue<PrintJob>();
    
    public void AddJob(string document, int pages)
    {
        PrintJob job = new PrintJob(document, pages);
        jobs.Enqueue(job);
        Console.WriteLine($"İş eklendi: {document}");
    }
    
    public void ProcessNextJob()
    {
        if (jobs.Count > 0)
        {
            PrintJob job = jobs.Dequeue();
            Console.WriteLine($"Yazdırılıyor: {job.Document}");
            // Yazdırma işlemi...
        }
        else
        {
            Console.WriteLine("Kuyruk boş!");
        }
    }
    
    public int JobsWaiting => jobs.Count;
}
```

### 3. Hot Potato Game (Josephus Problem)
```csharp
public string HotPotato(string[] names, int num)
{
    Queue<string> queue = new Queue<string>();
    
    // Herkesi kuyruğa ekle
    foreach (string name in names)
    {
        queue.Enqueue(name);
    }
    
    while (queue.Count > 1)
    {
        // num kadar döndür
        for (int i = 0; i < num; i++)
        {
            string person = queue.Dequeue();
            queue.Enqueue(person);  // Arkaya geri ekle
        }
        
        // Son kişiyi eleme
        string eliminated = queue.Dequeue();
        Console.WriteLine($"Elenen: {eliminated}");
    }
    
    return queue.Dequeue(); // Son kalan
}

// Kullanım: HotPotato(["Ali", "Ayşe", "Mehmet", "Fatma"], 3)
```

### 4. Multi-level Queue (Öncelik Sırası)
```csharp
public class PriorityQueue
{
    private Queue<Task> highPriority = new Queue<Task>();
    private Queue<Task> normalPriority = new Queue<Task>();
    private Queue<Task> lowPriority = new Queue<Task>();
    
    public void AddTask(Task task)
    {
        switch (task.Priority)
        {
            case Priority.High:
                highPriority.Enqueue(task);
                break;
            case Priority.Normal:
                normalPriority.Enqueue(task);
                break;
            case Priority.Low:
                lowPriority.Enqueue(task);
                break;
        }
    }
    
    public Task GetNextTask()
    {
        // Yüksek öncelik → Normal → Düşük sırasıyla
        if (highPriority.Count > 0)
            return highPriority.Dequeue();
        else if (normalPriority.Count > 0)
            return normalPriority.Dequeue();
        else if (lowPriority.Count > 0)
            return lowPriority.Dequeue();
        else
            return null;
    }
}
```

## Queue Türleri

### 1. Simple Queue
- Standart FIFO davranış
- En yaygın kullanılan tür

### 2. Circular Queue  
- Array sonuna gelince başa döner
- Bellek efficient

### 3. Priority Queue
- Elemanların öncelik sırası var
- Heap veri yapısı ile implement edilir

### 4. Deque (Double-ended Queue)
- Her iki ucundan da ekleme/çıkarma
- Hem Stack hem Queue gibi davranabilir

## Queue vs Stack - Detaylı Karşılaştırma

| Özellik | Queue (FIFO) | Stack (LIFO) |
|---------|-------------|-------------|
| **Ekleme** | Arkaya (rear) | Üste (top) |
| **Çıkarma** | Önden (front) | Üstten (top) |
| **Kullanım** | Sıra takip | Geri alma |
| **Algoritma** | BFS | DFS |
| **Gerçek hayat** | Market kuyruğu | Tabak yığını |

## Queue Ne Zaman Kullanılır?

### ✅ Queue Kullan Eğer:
- **FIFO** davranış gerekiyorsa
- **BFS** algoritması uyguluyorsan
- **Task scheduling** yapıyorsan
- **Buffering** gerekiyorsa (IO operations)
- **Level-order traversal** (tree'lerde)

### ❌ Queue Kullanma Eğer:
- **LIFO** davranış istiyorsan (Stack kullan)
- **Random access** gerekiyorsan (Array kullan)
- **Priority** önemliyse (PriorityQueue kullan)
- **Arama** operasyonu çok önemliyse

## İleri Seviye: Deque (Double-ended Queue)

```csharp
// .NET'te Deque yok, ama LinkedList ile simüle edebiliriz
LinkedList<int> deque = new LinkedList<int>();

// Başa ekleme/çıkarma (Stack gibi)
deque.AddFirst(10);
int front = deque.First.Value;
deque.RemoveFirst();

// Sona ekleme/çıkarma (Queue gibi)  
deque.AddLast(20);
int back = deque.Last.Value;
deque.RemoveLast();
```

Queue, sistemlerin adil ve düzenli çalışması için kritik bir veri yapısı. Her yerde karşılaştığın ama fark etmediğin bir kavram!