# Stack (Yığın) - LIFO Veri Yapısı

## Stack Nedir? LIFO Prensibi

Stack, **tabak yığını** gibi düşün. Bulaşık yıkarken tabakları üst üste koyarsın, sonra da en üsttekinden alırsın. **Son giren, ilk çıkar** (LIFO - Last In, First Out) prensibiyle çalışır.

### Gerçek Hayattan Stack Örnekleri:
1. **Tabak yığını:** En üstteki tabağı alırsın
2. **Kitap yığını:** En üstteki kitabı okursun
3. **Geri alma (Undo):** Son yaptığın işlemi geri alırsın
4. **Fonksiyon çağrıları:** Son çağrılan fonksiyon ilk tamamlanır

### Neden Bu Kadar Önemli?
- **Recursive algoritmalarda** temel
- **Function call stack** - her program kullanır
- **Expression evaluation** - matematiksel ifadeleri hesaplar
- **Undo/Redo** functionality
- **Parentheses matching** - parantez kontrolü

## Stack'in Temel İşlemleri

Stack'te sadece **4 temel işlem** var:

### 1. Push - Üste Ekleme O(1) ⚡
```csharp
// En üste eleman ekle
stack.Push(element);
```

### 2. Pop - Üstten Alma O(1) ⚡
```csharp
// En üstteki elemanı al ve kaldır
element = stack.Pop();
```

### 3. Peek/Top - Üsttekine Bakma O(1) ⚡
```csharp
// En üstteki elemanı göster ama kaldırma
element = stack.Peek();
```

### 4. IsEmpty - Boş mu Kontrolü O(1) ⚡
```csharp
// Stack boş mu?
bool isEmpty = stack.Count == 0;
```

## Array ile Stack Implementation

```csharp
public class MyStack
{
    private int[] items;
    private int top;        // En üstteki elemanın index'i
    private int capacity;
    
    public MyStack(int size)
    {
        items = new int[size];
        capacity = size;
        top = -1;  // Boş stack'te top = -1
    }
    
    // Push - O(1)
    public void Push(int item)
    {
        if (top >= capacity - 1)
            throw new StackOverflowException("Stack dolu!");
        
        items[++top] = item;  // top'u artır, elemanı ekle
    }
    
    // Pop - O(1)
    public int Pop()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Stack boş!");
        
        return items[top--];  // Elemanı döndür, top'u azalt
    }
    
    // Peek - O(1)
    public int Peek()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Stack boş!");
        
        return items[top];    // Sadece göster, kaldırma
    }
    
    // IsEmpty - O(1)
    public bool IsEmpty()
    {
        return top == -1;
    }
    
    public int Count => top + 1;
}
```

## LinkedList ile Stack Implementation

```csharp
public class LinkedStack
{
    private ListNode head;  // Stack'in tepesi
    
    private class ListNode
    {
        public int Data { get; set; }
        public ListNode Next { get; set; }
        
        public ListNode(int data)
        {
            Data = data;
            Next = null;
        }
    }
    
    // Push - Başa ekleme O(1)
    public void Push(int item)
    {
        ListNode newNode = new ListNode(item);
        newNode.Next = head;    // Yeni node eski head'i gösterir
        head = newNode;         // Head artık yeni node
    }
    
    // Pop - Baştan silme O(1)
    public int Pop()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Stack boş!");
        
        int data = head.Data;
        head = head.Next;       // Head'i bir sonrakine kaydır
        return data;
    }
    
    // Peek - O(1)
    public int Peek()
    {
        if (IsEmpty())
            throw new InvalidOperationException("Stack boş!");
        
        return head.Data;
    }
    
    public bool IsEmpty() => head == null;
}
```

## Stack İşlemlerinin Görsel Açıklaması

```
Stack Durumu:    [Boş]

Push(10):        [10]     ← top

Push(20):        [20]     ← top
                 [10]

Push(30):        [30]     ← top
                 [20]
                 [10]

Pop():           [20]     ← top  (30 döndürüldü)
                 [10]

Peek():          [20]     ← top  (20 gösterildi, kaldırılmadı)
                 [10]
```

## .NET'te Stack<T> Kullanımı

```csharp
// .NET'in hazır Stack'i
Stack<int> stack = new Stack<int>();

// Push - ekleme
stack.Push(10);
stack.Push(20);
stack.Push(30);

Console.WriteLine($"Count: {stack.Count}"); // 3

// Peek - göz atma
int top = stack.Peek(); // 30 (kaldırılmaz)

// Pop - alma
int popped = stack.Pop(); // 30 (kaldırılır)

// Contains - arama
bool has20 = stack.Contains(20); // true

// ToArray - diziye çevirme
int[] array = stack.ToArray(); // [20, 10] (ters sırada!)
```

## Stack'in Gerçek Hayat Uygulamaları

### 1. Parantez Kontrolü (Balanced Parentheses)
```csharp
public bool IsValidParentheses(string s)
{
    Stack<char> stack = new Stack<char>();
    
    foreach (char c in s)
    {
        if (c == '(' || c == '[' || c == '{')
        {
            stack.Push(c);  // Açılış parantezi stack'e at
        }
        else if (c == ')' || c == ']' || c == '}')
        {
            if (stack.Count == 0) return false; // Eşleşmeyen kapanış
            
            char last = stack.Pop();
            
            // Eşleşme kontrolü
            if ((c == ')' && last != '(') ||
                (c == ']' && last != '[') ||
                (c == '}' && last != '{'))
            {
                return false;
            }
        }
    }
    
    return stack.Count == 0; // Hepsi eşleşti mi?
}

// Kullanım:
// IsValidParentheses("({[]})") → true
// IsValidParentheses("([)]")   → false
```

### 2. Postfix Notation Hesaplama
```csharp
public int EvaluatePostfix(string expression)
{
    Stack<int> stack = new Stack<int>();
    string[] tokens = expression.Split(' ');
    
    foreach (string token in tokens)
    {
        if (int.TryParse(token, out int number))
        {
            stack.Push(number);  // Sayı ise stack'e at
        }
        else
        {
            // Operator ise son 2 sayıyı al ve işlem yap
            int b = stack.Pop();
            int a = stack.Pop();
            
            switch (token)
            {
                case "+": stack.Push(a + b); break;
                case "-": stack.Push(a - b); break;
                case "*": stack.Push(a * b); break;
                case "/": stack.Push(a / b); break;
            }
        }
    }
    
    return stack.Pop(); // Son sonuç
}

// Kullanım: "2 3 + 4 *" → ((2+3)*4) = 20
```

### 3. Undo Functionality
```csharp
public class TextEditor
{
    private string text = "";
    private Stack<string> undoStack = new Stack<string>();
    
    public void Type(string newText)
    {
        undoStack.Push(text);  // Mevcut durumu kaydet
        text += newText;
    }
    
    public void Undo()
    {
        if (undoStack.Count > 0)
        {
            text = undoStack.Pop();  // Önceki duruma dön
        }
    }
    
    public string GetText() => text;
}
```

### 4. Fonksiyon Çağrı Stack'i (Call Stack)
```csharp
// Recursive Fibonacci - Call stack kullanır
public int Fibonacci(int n)
{
    Console.WriteLine($"Fibonacci({n}) çağrıldı");
    
    if (n <= 1) return n;
    
    // Stack'e 2 çağrı eklenir
    int result = Fibonacci(n - 1) + Fibonacci(n - 2);
    
    Console.WriteLine($"Fibonacci({n}) tamamlandı");
    return result;
}

// Fibonacci(3) çağrı sırası:
// Push: Fibonacci(3)
//   Push: Fibonacci(2)
//     Push: Fibonacci(1) → Pop (return 1)
//     Push: Fibonacci(0) → Pop (return 0)
//   Pop: Fibonacci(2) returns 1
//   Push: Fibonacci(1) → Pop (return 1)
// Pop: Fibonacci(3) returns 2
```

## Stack vs Diğer Veri Yapıları

| Özellik | Stack | Array | LinkedList |
|---------|-------|--------|------------|
| **Erişim** | Sadece üst O(1) | Index ile O(1) | Sıralı O(n) |
| **Ekleme** | Sadece üste O(1) | Sona O(1) | Başa O(1) |
| **Silme** | Sadece üstten O(1) | Sondan O(1) | Baştan O(1) |
| **Arama** | Desteklenmez | O(n) | O(n) |
| **Kullanım** | LIFO işlemler | Genel amaçlı | Dinamik boyut |

## Stack Ne Zaman Kullanılır?

### ✅ Stack Kullan Eğer:
- **LIFO** davranış gerekiyorsa
- **Undo/Redo** functionality lazımsa  
- **Recursive** algoritma iterative yapıyorsan
- **Expression parsing** yapıyorsan
- **Backtracking** algoritmalarında

### ❌ Stack Kullanma Eğer:
- **Random access** gerekiyorsa
- **FIFO** davranış istiyorsan (Queue kullan)
- **Ortadaki elemanları** sık işliyorsan
- **Arama** operasyonu çok önemliyse

## Önemli Stack Kavramları

1. **Stack Overflow:** Stack dolunca olur - recursive çağrılarda dikkat!
2. **Stack Underflow:** Boş stack'ten pop yapmaya çalışınca
3. **Call Stack:** Her programın fonksiyon çağrıları için kullandığı stack
4. **DFS (Depth-First Search):** Graph traversal'da stack kullanır

Stack, basit ama çok güçlü bir veri yapısı. Recursive düşünceyi anlamak için de mükemmel bir araç!