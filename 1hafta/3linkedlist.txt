# LinkedList (Bağlı Liste) - Esnek Veri Yapısı

## LinkedList Nedir? Array'den Farkı Ne?

LinkedList'i **tren vagonu** gibi düşün. Her vagon (node) iki şey taşır:
1. **Yolcu (data):** Asıl sakladığın veri
2. **Sonraki vagonun numarası (pointer):** Bir sonraki node'un adresi

Array'de elemanlar yan yana sıralı apartman daireleri gibiydi. LinkedList'te ise elemanlar şehrin farklı yerlerinde dağınık evler gibi, ama her ev bir sonrakinin adresini biliyor.

### Gerçek Hayattan Benzetme: Hazine Avı
Düşün ki hazine avı oynuyorsun:
- **Array:** Hazine haritasında "X işareti 5. adımda" yazıyor → Direkt gidiyorsun
- **LinkedList:** İlk ipucu diyor ki "İkinci ipucunu çeşmede ara", oradan "Üçüncü ipucunu ağaçta ara" → Sırayla takip etmen gerekiyor

Bu yüzden LinkedList'te elemanlara erişim O(n), Array'de O(1).

## Node Yapısı - Temel Yapı Taşı

```csharp
// Basit Node sınıfı
public class ListNode
{
    public int Data { get; set; }        // Veri kısmı
    public ListNode Next { get; set; }   // Sonraki node'u gösterer

    public ListNode(int data)
    {
        Data = data;
        Next = null; // Başlangıçta kimseyi göstermiyor
    }
}
```

### Node'ların Bellekteki Durumu:
```
Array:     [10][20][30][40]  ← Yan yana, ardışık
           
LinkedList: [10]→   [20]→   [30]→   [40]→ null
             ↑       ↑       ↑       ↑
           Farklı   Farklı  Farklı  Farklı
           adresler adresler adresler adresler
```

## LinkedList'in Süper Güçleri ve Zayıflıkları

### 🚀 Süper Güçleri:
1. **Dinamik boyut:** İstediğin kadar büyüyebilir
2. **Başa ekleme çok hızlı:** O(1) - Sadece pointer değiştir
3. **Bellek efficient:** Sadece ihtiyacın kadar yer kullanır
4. **Esnek:** Ortadan ekleme/silme Array'den kolay

### 😕 Zayıflıkları:
1. **Yavaş erişim:** i'nci elemana ulaşmak için baştan sayman gerek - O(n)
2. **Extra bellek:** Her node için pointer de saklanıyor
3. **Cache unfriendly:** Elemanlar bellekte dağınık
4. **No random access:** Index ile direkt erişim yok

## Temel LinkedList İşlemleri

### 1. Başa Ekleme - O(1) ⚡

```csharp
public class SimpleLinkedList
{
    private ListNode head;
    
    public void AddFirst(int data)
    {
        ListNode newNode = new ListNode(data);
        newNode.Next = head;  // Yeni node eski head'i gösterir
        head = newNode;       // Head artık yeni node'u gösterir
    }
}

// Örnek:
// Başlangıç: head → [20] → [30] → null
// AddFirst(10) sonrası: head → [10] → [20] → [30] → null
```

### 2. Sona Ekleme - O(n) 🐌

```csharp
public void AddLast(int data)
{
    ListNode newNode = new ListNode(data);
    
    if (head == null) // Liste boşsa
    {
        head = newNode;
        return;
    }
    
    // Son node'u bul - Baştan sona yürümen gerek!
    ListNode current = head;
    while (current.Next != null)
    {
        current = current.Next;
    }
    
    current.Next = newNode; // Son node'un next'ini yeni node yap
}
```

### 3. Arama - O(n) 🔍

```csharp
public bool Contains(int data)
{
    ListNode current = head;
    
    while (current != null)
    {
        if (current.Data == data)
            return true;
        current = current.Next; // Bir sonraki node'a geç
    }
    
    return false; // Bulunamadı
}
```

### 4. Silme - O(n) 

```csharp
public bool Remove(int data)
{
    if (head == null) return false;
    
    // İlk node silinecekse - Özel durum
    if (head.Data == data)
    {
        head = head.Next; // Head'i bir sonrakine kaydır
        return true;
    }
    
    // Silinecek node'un öncesini bul
    ListNode current = head;
    while (current.Next != null && current.Next.Data != data)
    {
        current = current.Next;
    }
    
    // Bulunduysa bypass et
    if (current.Next != null)
    {
        current.Next = current.Next.Next; // Aradan çıkar
        return true;
    }
    
    return false;
}
```

## Görsel LinkedList İşlemleri

### Ekleme İşlemi:
```
Öncesi: head → [10] → [30] → null
        
20'yi 10 ile 30 arasına eklemek:
1. Yeni node oluştur: [20]
2. [20].Next = [30]
3. [10].Next = [20]

Sonrası: head → [10] → [20] → [30] → null
```

### Silme İşlemi:
```
Öncesi: head → [10] → [20] → [30] → null

20'yi silmek:
1. 20'nin öncesini bul: [10]
2. [10].Next = [20].Next (yani [30])

Sonrası: head → [10] → [30] → null
        [20] → çöpte (garbage collected)
```

## Doubly LinkedList - İleri Geri Hareket

```csharp
public class DoublyListNode
{
    public int Data { get; set; }
    public DoublyListNode Next { get; set; }    // İleriye pointer
    public DoublyListNode Prev { get; set; }    // Geriye pointer
    
    public DoublyListNode(int data)
    {
        Data = data;
        Next = null;
        Prev = null;
    }
}
```

### Avantajları:
- **Geriye gidebilme:** Bazen çok kullanışlı
- **Kolay silme:** Önceki node'u bulmaya gerek yok

### Dezavantajı:
- **Daha fazla bellek:** Her node'da 2 pointer

## LinkedList vs Array - Kapışma!

| İşlem | Array | LinkedList |
|-------|-------|-----------|
| **Erişim (i'nci eleman)** | O(1) ⚡ | O(n) 🐌 |
| **Başa ekleme** | O(n) 🐌 | O(1) ⚡ |
| **Sona ekleme** | O(1) ⚡ | O(n) 🐌 |
| **Ortaya ekleme** | O(n) 🐌 | O(n) 🐌 |
| **Arama** | O(n) 🐌 | O(n) 🐌 |
| **Bellek kullanımı** | Az ⚡ | Fazla 🐌 |

## LinkedList Ne Zaman Kullanmalı?

### ✅ LinkedList Kullan Eğer:
- **Sık sık başa ekleme** yapıyorsan
- **Boyut çok değişkensse**
- **Bellek parçalanması** sorun değilse
- **Undo/Redo** functionality lazımsa

### ❌ LinkedList Kullanma Eğer:
- **Random access** gerekiyorsa (index ile erişim)
- **Cache performance** kritikse
- **Bellek tasarrufu** önemliyse
- **Sık arama** yapacaksan

## .NET'te LinkedList<T>

```csharp
// .NET'in hazır LinkedList'i
LinkedList<int> list = new LinkedList<int>();

// Ekleme
list.AddFirst(10);  // Başa ekle
list.AddLast(30);   // Sona ekle

LinkedListNode<int> node = list.Find(10); // Node'u bul
list.AddAfter(node, 20); // 10'dan sonra 20 ekle

// Çıktı: 10 ↔ 20 ↔ 30

// Silme
list.Remove(20);    // Değer ile sil
list.RemoveFirst(); // Baştan sil
list.RemoveLast();  // Sondan sil
```

## Pratik Kullanım Örnekleri

1. **Undo/Redo sistemi:** Her işlem bir node
2. **Müzik çalar:** Şarkılar arası geçiş
3. **Browser history:** İleri/geri butonları
4. **LRU Cache:** En az kullanılan elemanı at

LinkedList'i anlamak, pointer mantığını anlamaktır. Bu da daha gelişmiş veri yapılarının (Tree, Graph) temelini oluşturur!