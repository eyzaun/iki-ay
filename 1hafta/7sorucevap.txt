# Hafta 1 DSA - Soru & Cevap

## ğŸ§® Big-O Notation

**S1: Big-O notation nedir ve neden Ã¶nemlidir?**
**C:** Big-O, algoritmalarÄ±n performansÄ±nÄ± Ã¶lÃ§en bir notasyondur. AlgoritmanÄ±n en kÃ¶tÃ¼ durumda ne kadar sÃ¼receÄŸini gÃ¶sterir. Ã–nemli Ã§Ã¼nkÃ¼ farklÄ± algoritmalarÄ± karÅŸÄ±laÅŸtÄ±rabilir ve bÃ¼yÃ¼k veri setlerinde hangisinin daha iyi olacaÄŸÄ±nÄ± Ã¶nceden bilebiliriz.

**S2: O(1) ve O(n) arasÄ±ndaki fark nedir? Ã–rnek verin.**
**C:** 
- **O(1):** Veri boyutu ne olursa olsun hep aynÄ± sÃ¼re. Ã–rnek: Array'de index ile eriÅŸim `arr[5]`
- **O(n):** Veri boyutu 2 katÄ±na Ã§Ä±kÄ±nca sÃ¼re de 2 katÄ±na Ã§Ä±kar. Ã–rnek: Array'de linear search

**S3: AÅŸaÄŸÄ±daki kodun Big-O karmaÅŸÄ±klÄ±ÄŸÄ± nedir?**
```csharp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        Console.WriteLine(i + j);
    }
}
```
**C:** **O(nÂ²)** - Ä°Ã§ iÃ§e iki dÃ¶ngÃ¼ var ve ikisi de n kez Ã§alÄ±ÅŸÄ±yor. n Ã— n = nÂ²

**S4: Binary Search neden O(log n) karmaÅŸÄ±klÄ±ÄŸÄ±na sahiptir?**
**C:** Her adÄ±mda arama alanÄ±nÄ± yarÄ±ya bÃ¶ldÃ¼ÄŸÃ¼ iÃ§in. 1000 elemanlÄ±k array'de en fazla 10 adÄ±mda (logâ‚‚ 1000 â‰ˆ 10) sonuca ulaÅŸÄ±r.

**S5: O(n + nÂ²) ifadesi nasÄ±l sadeleÅŸir?**
**C:** **O(nÂ²)** olur. Big-O'da en bÃ¼yÃ¼k terim alÄ±nÄ±r, sabitler ve kÃ¼Ã§Ã¼k terimler ihmal edilir.

---

## ğŸ“Š Arrays (Diziler)

**S1: Array'in en bÃ¼yÃ¼k avantajÄ± ve dezavantajÄ± nedir?**
**C:** 
- **Avantaj:** Index ile O(1) hÄ±zÄ±nda eriÅŸim
- **Dezavantaj:** Sabit boyut (klasik array'lerde) ve ortaya ekleme/silme pahalÄ± (O(n))

**S2: List<T> ile Array arasÄ±ndaki temel fark nedir?**
**C:** Array sabit boyutlu, List<T> dinamik boyutlu. List<T> ihtiyaÃ§ oldukÃ§a bÃ¼yÃ¼r ama bu bazen O(n) ekleme maliyeti getirir (yeniden boyutlandÄ±rma).

**S3: Two Pointers tekniÄŸi nedir ve ne zaman kullanÄ±lÄ±r?**
**C:** Ä°ki iÅŸaretÃ§i kullanarak array'i verimli gezmek. Genelde sorted array'lerde kullanÄ±lÄ±r. Ã–rnek: palindrome kontrolÃ¼ (baÅŸtan ve sondan ortaya doÄŸru)

**S4: Sliding Window tekniÄŸi neyi Ã§Ã¶zer?**
**C:** Sabit boyutlu alt dizilerdeki iÅŸlemleri optimize eder. Ã–rnek: 3 elemanlÄ± en bÃ¼yÃ¼k toplamÄ± bulmak iÃ§in tÃ¼m pencereyi yeniden hesaplamak yerine, eski elemanÄ± Ã§Ä±kar yeniyi ekle.

**S5: Array'de bir elemanÄ± ortaya eklemek neden O(n) sÃ¼rer?**
**C:** Eklenecek pozisyondan sonraki tÃ¼m elemanlarÄ± bir saÄŸa kaydÄ±rmak gerekir. En kÃ¶tÃ¼ durumda (baÅŸa ekleme) tÃ¼m elemanlar kaydÄ±rÄ±lÄ±r.

---

## ğŸ”— LinkedList (BaÄŸlÄ± Liste)

**S1: LinkedList'in Array'e gÃ¶re ana avantajÄ± nedir?**
**C:** **Dinamik boyut** ve **baÅŸa ekleme O(1)**. Array'de baÅŸa ekleme O(n) sÃ¼rerken, LinkedList'te sadece pointer deÄŸiÅŸtirme yeterli.

**S2: LinkedList'te neden random access (index ile eriÅŸim) yok?**
**C:** Elemanlar bellekte ardÄ±ÅŸÄ±k deÄŸil, pointer'larla baÄŸlÄ±. 5. elemana ulaÅŸmak iÃ§in baÅŸtan 5 adÄ±m yÃ¼rÃ¼mek gerekir.

**S3: Doubly LinkedList ne zaman Single LinkedList'ten daha avantajlÄ±?**
**C:** Geriye doÄŸru hareket gerektiÄŸinde veya bir node'u silmek iÃ§in Ã¶nceki node'a ihtiyaÃ§ duyduÄŸunda. Browser history gibi.

**S4: LinkedList'te bir elemanÄ± silmek iÃ§in hangi adÄ±mlar gerekir?**
**C:** 
1. Silinecek node'un Ã¶ncesini bul
2. Ã–nceki node'un next'ini, silinecek node'un next'ine baÄŸla
3. Silinecek node artÄ±k eriÅŸilemez (garbage collected)

**S5: Memory aÃ§Ä±sÄ±ndan LinkedList vs Array karÅŸÄ±laÅŸtÄ±rmasÄ±?**
**C:** Array daha verimli (sadece data), LinkedList her node iÃ§in ekstra pointer saklar. Ama LinkedList sadece ihtiyaÃ§ kadar yer kullanÄ±r.

---

## ğŸ“š Stack (YÄ±ÄŸÄ±n)

**S1: LIFO prensibi nedir ve Stack'te nasÄ±l uygulanÄ±r?**
**C:** Last In, First Out - son giren ilk Ã§Ä±kar. Stack'te sadece en Ã¼stteki elemana eriÅŸebilirsin, tÄ±pkÄ± tabak yÄ±ÄŸÄ±nÄ± gibi.

**S2: Stack'in 4 temel operasyonu nedir?**
**C:** 
- **Push:** Ãœste ekleme
- **Pop:** Ãœstten alma ve kaldÄ±rma  
- **Peek:** Ãœsttekine bakma (kaldÄ±rmadan)
- **IsEmpty:** BoÅŸ mu kontrolÃ¼

**S3: Recursive fonksionlar Stack'i nasÄ±l kullanÄ±r?**
**C:** Her fonksiyon Ã§aÄŸrÄ±sÄ± call stack'e eklenir. Fonksiyon bitince stack'ten Ã§Ä±kar. Bu yÃ¼zden Ã§ok derin recursion stack overflow'a neden olur.

**S4: Parantez kontrolÃ¼ algoritmasÄ± Stack'i nasÄ±l kullanÄ±r?**
**C:** AÃ§Ä±lÄ±ÅŸ parantezi gÃ¶rÃ¼nce stack'e push, kapanÄ±ÅŸ gÃ¶rÃ¼nce pop yapÄ±p eÅŸleÅŸme kontrol et. Son'da stack boÅŸsa balanced.

**S5: Stack ne zaman Queue'dan daha uygun?**
**C:** LIFO davranÄ±ÅŸ gerektiÄŸinde: undo/redo, function calls, expression evaluation, DFS algorithm.

---

## ğŸš¶â€â™‚ï¸ Queue (Kuyruk)

**S1: FIFO prensibi nedir ve hangi durumlarda gerekir?**
**C:** First In, First Out - ilk giren ilk Ã§Ä±kar. Market kuyruÄŸu, task scheduling, BFS algorithm gibi adil sÄ±ralama gereken durumlarda.

**S2: Queue'nun temel operasyonlarÄ± nelerdir?**
**C:**
- **Enqueue:** Arkaya ekleme
- **Dequeue:** Ã–nden alma
- **Front/Peek:** Ã–ndekine bakma
- **IsEmpty:** BoÅŸ mu kontrolÃ¼

**S3: Circular Queue'nun normal Queue'ya avantajÄ± nedir?**
**C:** Array implementasyonunda yer tasarrufu. Normal queue'da elemanlar Ã§Ä±ktÄ±kÃ§a baÅŸta boÅŸ alan kalÄ±r ama kullanÄ±lamaz. Circular'da bu alan tekrar kullanÄ±lÄ±r.

**S4: BFS (Breadth-First Search) neden Queue kullanÄ±r?**
**C:** BFS, komÅŸularÄ± level-level gezer. Ã–nce 1. level'daki tÃ¼m node'larÄ±, sonra 2. level'dakileri... Queue FIFO yapÄ±sÄ±yla bu sÄ±rayÄ± korur.

**S5: Queue ile Stack arasÄ±ndaki temel fark nedir?**
**C:** **Queue:** Ä°lk giren ilk Ã§Ä±kar (adil kuyruk), **Stack:** Son giren ilk Ã§Ä±kar (tabak yÄ±ÄŸÄ±nÄ±). FarklÄ± problemler iÃ§in farklÄ± veri yapÄ±larÄ±.

---

## ğŸ—‚ï¸ HashMap (HashTable)

**S1: HashMap neden O(1) arama sÃ¼resine sahiptir?**
**C:** Hash function sayesinde key'den direkt index hesaplar. Array'deki index eriÅŸimi O(1) olduÄŸu iÃ§in HashMap de O(1).

**S2: Hash collision nedir ve nasÄ±l Ã§Ã¶zÃ¼lÃ¼r?**
**C:** Ä°ki farklÄ± key aynÄ± index'e dÃ¼ÅŸtÃ¼ÄŸÃ¼nde collision olur. **Separate Chaining** (her index'te LinkedList) veya **Open Addressing** ile Ã§Ã¶zÃ¼lÃ¼r.

**S3: Load Factor nedir ve neden Ã¶nemlidir?**
**C:** Load Factor = Eleman SayÄ±sÄ± / Table Boyutu. 0.75'ten yÃ¼ksek olunca collision artar, performans dÃ¼ÅŸer. Bu durumda rehashing gerekir.

**S4: HashMap ile Array'in performans farkÄ± nedir?**
**C:**
- **HashMap:** Search O(1), Insert O(1), Delete O(1)
- **Array:** Search O(n), Insert O(n), Delete O(n)
- Ama HashMap'te ekstra memory ve order yok.

**S5: Ä°yi bir hash function'Ä±n Ã¶zellikleri nelerdir?**
**C:** 
- **Uniform distribution:** ElemanlarÄ± eÅŸit daÄŸÄ±tÄ±r
- **Deterministic:** AynÄ± input, aynÄ± output  
- **Fast:** HÄ±zlÄ± hesaplanÄ±r
- **Avalanche effect:** KÃ¼Ã§Ã¼k deÄŸiÅŸiklik bÃ¼yÃ¼k farka yol aÃ§ar

**S6: Dictionary<string, int> ve int[] arasÄ±nda ne zaman hangisini kullanÄ±rsÄ±n?**
**C:** 
- **Dictionary:** Key-value iliÅŸkisi, hÄ±zlÄ± lookup, deÄŸiÅŸken boyut
- **Array:** Index-based eriÅŸim, memory efficiency, sÄ±ralÄ± veri

---

## ğŸ§  Genel Kavramlar

**S1: Hangi veri yapÄ±sÄ± hangi durum iÃ§in en uygun?**
**C:**
- **HÄ±zlÄ± eriÅŸim:** Array (index varsa) veya HashMap (key varsa)
- **SÄ±k ekleme/silme (baÅŸta):** LinkedList veya Stack
- **SÄ±ralÄ± iÅŸleme:** Queue
- **Undo/Redo:** Stack
- **Key-value mapping:** HashMap

**S2: Memory vs Speed trade-off'unu aÃ§Ä±klayÄ±n.**
**C:** Genelde hÄ±z iÃ§in extra memory kullanÄ±rÄ±z. HashMap extra pointer'lar saklar ama O(1) arama verir. Array minimum memory kullanÄ±r ama bazÄ± iÅŸlemler O(n).

**S3: Cache-friendly veri yapÄ±sÄ± nedir?**
**C:** ElemanlarÄ± bellekte yan yana saklayan yapÄ±lar (Array). CPU cache'i ardÄ±ÅŸÄ±k veriyi hÄ±zlÄ± iÅŸler. LinkedList cache-unfriendly Ã§Ã¼nkÃ¼ elemanlar daÄŸÄ±nÄ±k.

Bu sorularla Hafta 1'in tÃ¼m Ã¶nemli kavramlarÄ±nÄ± pekiÅŸtirmiÅŸ oldun! ğŸ¯