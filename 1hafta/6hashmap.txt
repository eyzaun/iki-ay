# HashMap (HashTable) - HÄ±zlÄ± Arama Veri YapÄ±sÄ±

## HashMap Nedir? Sihirli HÄ±zÄ± Nereden Geliyor?

HashMap'i **devasa kÃ¼tÃ¼phanenin sihirli katalogu** gibi dÃ¼ÅŸÃ¼n. Normal kÃ¼tÃ¼phanede kitap arasan rafa rafa bakarsÄ±n (O(n)). Ama HashMap'te **hash function** dediÄŸimiz sihirli formÃ¼l, kitabÄ±n tam hangi rafta olduÄŸunu direkt sÃ¶ylÃ¼yor (O(1))!

### GerÃ§ek Hayattan Benzetme: Telefon Rehberi
Eski zamanlarda telefon rehberi alfabetik sÄ±ralÄ±ydÄ±. "Mehmet"i aradÄ±ÄŸÄ±n zaman M harfinden baÅŸlayÄ±p sÄ±rayla bakardÄ±n. 

HashMap'te ise sihirli bir formÃ¼l var:
- **"Mehmet"** â†’ Hash Function â†’ **Index 47**
- Direkt 47. kutuya gidip numarayÄ± alÄ±yorsun!

### Neden Bu Kadar HÄ±zlÄ±?
- **Array'in hÄ±zÄ±:** Index ile direkt eriÅŸim O(1)
- **Hash function'Ä±n gÃ¼cÃ¼:** Key'den index'i hemen hesaplÄ±yor
- **Smart organization:** Veriler akÄ±llÄ±ca daÄŸÄ±tÄ±lÄ±yor

## HashMap'in Temel BileÅŸenleri

### 1. Hash Function (Sihirli FormÃ¼l)
```csharp
// Basit hash function Ã¶rneÄŸi
public int SimpleHash(string key, int tableSize)
{
    int hash = 0;
    
    foreach (char c in key)
    {
        hash += (int)c;  // Karakterlerin ASCII deÄŸerlerini topla
    }
    
    return hash % tableSize;  // Table boyutuna gÃ¶re index
}

// Ã–rnek:
// "Ali" â†’ A(65) + l(108) + i(105) = 278
// 278 % 10 = 8 â†’ Index 8'e koy
```

### 2. Collision (Ã‡arpÄ±ÅŸma) Problemi
Ä°ki farklÄ± key aynÄ± index'i verse ne olur?

```
"Ali"  â†’ Hash â†’ Index 8
"Bob"  â†’ Hash â†’ Index 8  â† AynÄ± index! COLLISION!
```

### 3. Collision Resolution (Ã‡arpÄ±ÅŸma Ã‡Ã¶zÃ¼mÃ¼)

#### Separate Chaining (AyrÄ± Zincirleme)
```csharp
// Her index'te LinkedList tutuyoruz
public class HashMapWithChaining
{
    private LinkedList<KeyValuePair<string, int>>[] buckets;
    private int size;
    
    public HashMapWithChaining(int capacity)
    {
        buckets = new LinkedList<KeyValuePair<string, int>>[capacity];
        for (int i = 0; i < capacity; i++)
        {
            buckets[i] = new LinkedList<KeyValuePair<string, int>>();
        }
        size = 0;
    }
    
    private int Hash(string key)
    {
        int hash = 0;
        foreach (char c in key)
        {
            hash = (hash * 31 + c) % buckets.Length;
        }
        return Math.Abs(hash);
    }
    
    // Put - O(1) average case
    public void Put(string key, int value)
    {
        int index = Hash(key);
        var bucket = buckets[index];
        
        // AynÄ± key var mÄ± kontrol et
        foreach (var kvp in bucket)
        {
            if (kvp.Key == key)
            {
                // DeÄŸeri gÃ¼ncelle
                bucket.Remove(kvp);
                bucket.AddLast(new KeyValuePair<string, int>(key, value));
                return;
            }
        }
        
        // Yeni key, listeye ekle
        bucket.AddLast(new KeyValuePair<string, int>(key, value));
        size++;
    }
    
    // Get - O(1) average case
    public int Get(string key)
    {
        int index = Hash(key);
        var bucket = buckets[index];
        
        foreach (var kvp in bucket)
        {
            if (kvp.Key == key)
            {
                return kvp.Value;
            }
        }
        
        throw new KeyNotFoundException($"Key '{key}' bulunamadÄ±!");
    }
    
    // Contains - O(1) average case
    public bool ContainsKey(string key)
    {
        try
        {
            Get(key);
            return true;
        }
        catch (KeyNotFoundException)
        {
            return false;
        }
    }
}
```

## GÃ¶rsel HashMap Ä°ÅŸleyiÅŸi

```
Hash Table (size=5):

Index 0: [ ]
Index 1: ["Alice", 25] â†’ ["Bob", 30]  â† Collision, chaining
Index 2: [ ]  
Index 3: ["Charlie", 35]
Index 4: ["David", 40]

Put("Eve", 28):
"Eve" â†’ Hash â†’ Index 1
Index 1: ["Alice", 25] â†’ ["Bob", 30] â†’ ["Eve", 28]

Get("Bob"):
"Bob" â†’ Hash â†’ Index 1 â†’ LinkedList'te ara â†’ 30 dÃ¶ndÃ¼r
```

## .NET'te Dictionary<TKey, TValue> KullanÄ±mÄ±

```csharp
// .NET'in hash table implementasyonu
Dictionary<string, int> ages = new Dictionary<string, int>();

// Ekleme - O(1) average
ages["Alice"] = 25;
ages["Bob"] = 30;
ages.Add("Charlie", 35);  // Alternative syntax

// EriÅŸim - O(1) average  
int aliceAge = ages["Alice"];  // 25

// GÃ¼venli eriÅŸim
if (ages.TryGetValue("David", out int davidAge))
{
    Console.WriteLine($"David'in yaÅŸÄ±: {davidAge}");
}
else
{
    Console.WriteLine("David bulunamadÄ±");
}

// Kontrol - O(1) average
bool hasAlice = ages.ContainsKey("Alice");  // true
bool hasAge25 = ages.ContainsValue(25);     // true

// Silme - O(1) average
bool removed = ages.Remove("Bob");

// Iteration
foreach (var kvp in ages)
{
    Console.WriteLine($"{kvp.Key}: {kvp.Value}");
}

// Keys ve Values
var names = ages.Keys;    // TÃ¼m key'ler
var allAges = ages.Values; // TÃ¼m value'lar
```

## HashMap'in GerÃ§ek Hayat UygulamalarÄ±

### 1. Frequency Counting (Frekans Sayma)
```csharp
public Dictionary<char, int> CountCharacters(string text)
{
    Dictionary<char, int> frequencies = new Dictionary<char, int>();
    
    foreach (char c in text.ToLower())
    {
        if (char.IsLetter(c))
        {
            frequencies[c] = frequencies.GetValueOrDefault(c, 0) + 1;
        }
    }
    
    return frequencies;
}

// KullanÄ±m:
// CountCharacters("hello") â†’ {'h':1, 'e':1, 'l':2, 'o':1}
```

### 2. Two Sum Problem - O(n) Ã‡Ã¶zÃ¼m
```csharp
public int[] TwoSum(int[] nums, int target)
{
    Dictionary<int, int> map = new Dictionary<int, int>();
    
    for (int i = 0; i < nums.Length; i++)
    {
        int complement = target - nums[i];
        
        if (map.ContainsKey(complement))
        {
            return new int[] { map[complement], i };
        }
        
        map[nums[i]] = i;  // Mevcut sayÄ± ve index'i kaydet
    }
    
    return new int[0]; // BulunamadÄ±
}

// Ã–rnek: TwoSum([2,7,11,15], 9) â†’ [0,1] (2+7=9)
```

### 3. Cache Implementation (LRU Cache)
```csharp
public class LRUCache
{
    private Dictionary<int, LinkedListNode<CacheItem>> cache;
    private LinkedList<CacheItem> order;
    private int capacity;
    
    public LRUCache(int capacity)
    {
        this.capacity = capacity;
        cache = new Dictionary<int, LinkedListNode<CacheItem>>();
        order = new LinkedList<CacheItem>();
    }
    
    public int Get(int key)
    {
        if (cache.TryGetValue(key, out var node))
        {
            // Move to front (most recently used)
            order.Remove(node);
            order.AddFirst(node);
            return node.Value.Value;
        }
        return -1;
    }
    
    public void Put(int key, int value)
    {
        if (cache.TryGetValue(key, out var existingNode))
        {
            // Update existing
            existingNode.Value.Value = value;
            order.Remove(existingNode);
            order.AddFirst(existingNode);
        }
        else
        {
            // Add new
            if (cache.Count >= capacity)
            {
                // Remove least recently used
                var lastNode = order.Last;
                order.RemoveLast();
                cache.Remove(lastNode.Value.Key);
            }
            
            var newItem = new CacheItem { Key = key, Value = value };
            var newNode = order.AddFirst(newItem);
            cache[key] = newNode;
        }
    }
    
    private class CacheItem
    {
        public int Key { get; set; }
        public int Value { get; set; }
    }
}
```

### 4. Group Anagrams
```csharp
public List<List<string>> GroupAnagrams(string[] strs)
{
    Dictionary<string, List<string>> groups = new Dictionary<string, List<string>>();
    
    foreach (string str in strs)
    {
        // Key olarak sorted string kullan
        char[] chars = str.ToCharArray();
        Array.Sort(chars);
        string key = new string(chars);
        
        if (!groups.ContainsKey(key))
        {
            groups[key] = new List<string>();
        }
        
        groups[key].Add(str);
    }
    
    return groups.Values.ToList();
}

// Ã–rnek: ["eat","tea","tan","ate","nat","bat"]
// SonuÃ§: [["eat","tea","ate"], ["tan","nat"], ["bat"]]
```

## HashMap Performans Analizi

### âš¡ Ortalama Durumlar (Average Case):
- **Insert:** O(1)
- **Delete:** O(1)  
- **Search:** O(1)
- **Update:** O(1)

### ğŸŒ En KÃ¶tÃ¼ Durumlar (Worst Case):
- **TÃ¼m iÅŸlemler:** O(n) - TÃ¼m elemanlar aynÄ± index'e dÃ¼ÅŸerse

### ğŸ¯ Load Factor (Doluluk OranÄ±):
```
Load Factor = Eleman SayÄ±sÄ± / Table Boyutu

- Load Factor < 0.75: Ä°yi performans
- Load Factor > 0.75: Collision artar, rehashing gerekir
```

## HashMap vs DiÄŸer Veri YapÄ±larÄ±

| Ã–zellik | HashMap | Array | LinkedList | Binary Search Tree |
|---------|---------|--------|------------|-------------------|
| **Search** | O(1) avg âš¡ | O(n) ğŸŒ | O(n) ğŸŒ | O(log n) ğŸ“ˆ |
| **Insert** | O(1) avg âš¡ | O(n) ğŸŒ | O(1) âš¡ | O(log n) ğŸ“ˆ |
| **Delete** | O(1) avg âš¡ | O(n) ğŸŒ | O(n) ğŸŒ | O(log n) ğŸ“ˆ |
| **Order** | No âŒ | Yes âœ… | Yes âœ… | Yes âœ… |
| **Memory** | Extra ğŸ“Š | Minimal âš¡ | Extra ğŸ“Š | Extra ğŸ“Š |

## Hash Function Kalitesi

### Ä°yi Hash Function Ã–zellikleri:
1. **Uniform distribution:** ElemanlarÄ± eÅŸit daÄŸÄ±tÄ±r
2. **Deterministic:** AynÄ± input, aynÄ± output
3. **Fast computation:** HÄ±zlÄ± hesaplanÄ±r
4. **Avalanche effect:** KÃ¼Ã§Ã¼k deÄŸiÅŸiklik, bÃ¼yÃ¼k fark

```csharp
// .NET'in string hash function'Ä± (basitleÅŸtirilmiÅŸ)
public int GetHashCode(string str)
{
    int hash = 0;
    foreach (char c in str)
    {
        hash = hash * 31 + c;  // 31 prime sayÄ±sÄ±, iyi daÄŸÄ±tÄ±m saÄŸlar
    }
    return hash;
}
```

## HashMap Ne Zaman KullanÄ±lÄ±r?

### âœ… HashMap Kullan EÄŸer:
- **HÄ±zlÄ± lookup** gerekiyorsa
- **Key-value** iliÅŸkisi varsa  
- **Frequency counting** yapÄ±yorsan
- **Caching** gerekiyorsa
- **Set operations** (union, intersection) yapÄ±yorsan

### âŒ HashMap Kullanma EÄŸer:
- **Ordered data** gerekiyorsa (SortedDictionary kullan)
- **Memory critical** durumda (Array daha az yer kaplar)
- **Small datasets** (Array daha hÄ±zlÄ± olabilir)
- **Range queries** yapacaksan (Tree kullan)

## Ã–nemli HashMap VaryantlarÄ±

### 1. HashSet<T> - Sadece Key'ler
```csharp
HashSet<int> numbers = new HashSet<int>();
numbers.Add(1);
numbers.Add(2);
bool contains = numbers.Contains(1); // O(1)
```

### 2. SortedDictionary<K,V> - SÄ±ralÄ±
```csharp
SortedDictionary<string, int> sorted = new SortedDictionary<string, int>();
// Ä°Ã§eride Red-Black Tree kullanÄ±r, O(log n) operations
```

### 3. ConcurrentDictionary<K,V> - Thread-Safe
```csharp
ConcurrentDictionary<string, int> concurrent = new ConcurrentDictionary<string, int>();
// Multi-threading'de gÃ¼venli
```

HashMap, modern programlamanÄ±n kalbi! Neredeyse her projede kullanacaÄŸÄ±n, Ã§ok gÃ¼Ã§lÃ¼ bir veri yapÄ±sÄ±. HÄ±z konusunda rakipsiz!