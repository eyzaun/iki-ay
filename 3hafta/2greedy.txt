# Greedy Algorithms - Lokal Optimal SeÃ§imler

## Greedy Algorithm Nedir?

Greedy, **her adÄ±mda en iyi gÃ¶rÃ¼nen seÃ§imi** yapan algoritmadÄ±r. **"Åu anda elimdeki en iyi seÃ§eneÄŸi al, gerisini dÃ¼ÅŸÃ¼nme"** mantÄ±ÄŸÄ±.

### GerÃ§ek Hayattan Benzetme: Restoran SeÃ§imi
DÃ¼ÅŸÃ¼n ki aÃ§sÄ±n ve restoran arÄ±yorsun:
- **DP yaklaÅŸÄ±mÄ±:** TÃ¼m rotalarÄ± hesapla, en optimal yolu bul â†’ KarmaÅŸÄ±k ama optimal
- **Greedy yaklaÅŸÄ±mÄ±:** Her kavÅŸakta en yakÄ±n/gÃ¼zel gÃ¶rÃ¼nen restorana git â†’ Basit ama her zaman optimal deÄŸil

### Greedy'nin Temel Ã–zelliÄŸi:
**"Local optimal choice'lar global optimal solution'a gÃ¶tÃ¼rÃ¼r"** - Ama bu **her problem iÃ§in geÃ§erli deÄŸil**!

## Greedy vs DP - Temel Fark

```csharp
// DP: TÃ¼m seÃ§enekleri deÄŸerlendir
int dp(state) {
    if (baseCase) return value;
    
    int best = worst_value;
    for (choice in all_possible_choices) {
        best = Math.Max(best, choice + dp(new_state));
    }
    return best;
}

// Greedy: En iyi gÃ¶rÃ¼neni seÃ§, devam et
int greedy(problem) {
    int result = 0;
    while (problem_not_solved) {
        choice = find_best_local_choice();
        result += choice;
        update_problem_state();
    }
    return result;
}
```

## Classic Greedy Problems

### 1. Activity Selection Problem
**Problem:** Maximum sayÄ±da activity seÃ§ (overlapping olamazlar)

```csharp
public class ActivitySelection
{
    public class Activity
    {
        public int Start { get; set; }
        public int End { get; set; }
        public string Name { get; set; }
    }
    
    // Greedy Strategy: En erken biten activity'yi seÃ§
    public List<Activity> SelectActivities(List<Activity> activities)
    {
        // 1. End time'a gÃ¶re sÄ±rala - KEY INSIGHT!
        activities.Sort((a, b) => a.End.CompareTo(b.End));
        
        List<Activity> result = new List<Activity>();
        
        if (activities.Count > 0)
        {
            result.Add(activities[0]); // Ä°lk activity'yi seÃ§
            int lastEndTime = activities[0].End;
            
            // 2. Greedy choice: En erken biten uyumlu activity'yi seÃ§
            for (int i = 1; i < activities.Count; i++)
            {
                if (activities[i].Start >= lastEndTime) // Overlap yok
                {
                    result.Add(activities[i]);
                    lastEndTime = activities[i].End;
                }
            }
        }
        
        return result;
    }
}

// Ã–rnek:
// Activities: [(1,3), (2,5), (4,6), (6,7), (5,8), (8,9)]
// Sorted by end: [(1,3), (2,5), (4,6), (6,7), (5,8), (8,9)]
// Greedy seÃ§im: (1,3), (4,6), (6,7), (8,9) â†’ 4 activity
```

### 2. Fractional Knapsack
**Problem:** Items'i bÃ¶lebilirsin, maximum value elde et

```csharp
public class FractionalKnapsack
{
    public class Item
    {
        public int Weight { get; set; }
        public int Value { get; set; }
        public double Ratio => (double)Value / Weight; // Value per weight
    }
    
    // Greedy Strategy: En yÃ¼ksek value/weight ratio'yu seÃ§
    public double GetMaxValue(List<Item> items, int capacity)
    {
        // 1. Value/weight ratio'ya gÃ¶re sÄ±rala - KEY INSIGHT!
        items.Sort((a, b) => b.Ratio.CompareTo(a.Ratio));
        
        double totalValue = 0;
        int remainingCapacity = capacity;
        
        foreach (var item in items)
        {
            if (remainingCapacity <= 0) break;
            
            if (item.Weight <= remainingCapacity)
            {
                // TÃ¼m item'i al
                totalValue += item.Value;
                remainingCapacity -= item.Weight;
            }
            else
            {
                // Item'in bir kÄ±smÄ±nÄ± al (fractional)
                double fraction = (double)remainingCapacity / item.Weight;
                totalValue += item.Value * fraction;
                remainingCapacity = 0;
            }
        }
        
        return totalValue;
    }
}
```

### 3. Coin Change (Greedy Version)
**Problem:** Minimum coin sayÄ±sÄ±yla amount'Ä± yap (sadece standard coins iÃ§in Ã§alÄ±ÅŸÄ±r!)

```csharp
public class CoinChangeGreedy
{
    // Greedy Strategy: En bÃ¼yÃ¼k coin'i mÃ¼mkÃ¼n olduÄŸunca kullan
    public List<int> GetMinCoins(int[] coins, int amount)
    {
        // 1. Coins'i bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe sÄ±rala
        Array.Sort(coins, (a, b) => b.CompareTo(a));
        
        List<int> result = new List<int>();
        
        foreach (int coin in coins)
        {
            while (amount >= coin)
            {
                result.Add(coin);
                amount -= coin;
            }
        }
        
        return amount == 0 ? result : new List<int>(); // Impossible ise empty list
    }
}

// NOT: Bu sadece standard coin systems iÃ§in Ã§alÄ±ÅŸÄ±r!
// [1,5,10,25] â†’ Works perfectly
// [1,3,4] amount=6 â†’ Greedy: [4,1,1] (3 coins), Optimal: [3,3] (2 coins)
```

### 4. Meeting Rooms
**Problem:** Minimum meeting room sayÄ±sÄ±

```csharp
public class MeetingRooms
{
    public class Meeting
    {
        public int Start { get; set; }
        public int End { get; set; }
    }
    
    // Greedy Strategy: En erken biten meeting'i track et
    public int MinMeetingRooms(List<Meeting> meetings)
    {
        if (meetings.Count == 0) return 0;
        
        // Start ve end time'larÄ± ayrÄ± ayrÄ± sÄ±rala
        var startTimes = meetings.Select(m => m.Start).OrderBy(x => x).ToList();
        var endTimes = meetings.Select(m => m.End).OrderBy(x => x).ToList();
        
        int rooms = 0;
        int maxRooms = 0;
        int startPtr = 0, endPtr = 0;
        
        while (startPtr < startTimes.Count)
        {
            if (startTimes[startPtr] < endTimes[endPtr])
            {
                // Meeting baÅŸlÄ±yor, room gerekli
                rooms++;
                startPtr++;
                maxRooms = Math.Max(maxRooms, rooms);
            }
            else
            {
                // Meeting bitiyor, room boÅŸalÄ±yor
                rooms--;
                endPtr++;
            }
        }
        
        return maxRooms;
    }
    
    // Alternative: Priority Queue ile
    public int MinMeetingRoomsWithHeap(List<Meeting> meetings)
    {
        if (meetings.Count == 0) return 0;
        
        // Start time'a gÃ¶re sÄ±rala
        meetings.Sort((a, b) => a.Start.CompareTo(b.Start));
        
        // Min heap: En erken biten meeting'i track et
        var endTimes = new PriorityQueue<int, int>();
        
        foreach (var meeting in meetings)
        {
            // Biten meeting'leri temizle
            while (endTimes.Count > 0 && endTimes.Peek() <= meeting.Start)
            {
                endTimes.Dequeue();
            }
            
            // Yeni meeting'i ekle
            endTimes.Enqueue(meeting.End, meeting.End);
        }
        
        return endTimes.Count; // Concurrent meeting sayÄ±sÄ±
    }
}
```

## Advanced Greedy Examples

### 5. Jump Game
**Problem:** Array'in sonuna ulaÅŸabilir misin? (Her element max jump distance)

```csharp
public class JumpGame
{
    // Greedy Strategy: En uzaÄŸa ulaÅŸabildiÄŸin noktayÄ± track et
    public bool CanJump(int[] nums)
    {
        int maxReach = 0;
        
        for (int i = 0; i < nums.Length; i++)
        {
            if (i > maxReach) return false; // Bu noktaya ulaÅŸamÄ±yoruz
            
            maxReach = Math.Max(maxReach, i + nums[i]); // En uzaÄŸa ulaÅŸabileceÄŸimiz nokta
            
            if (maxReach >= nums.Length - 1) return true; // Sona ulaÅŸtÄ±k
        }
        
        return maxReach >= nums.Length - 1;
    }
    
    // Jump Game II: Minimum jump sayÄ±sÄ±
    public int Jump(int[] nums)
    {
        int jumps = 0;
        int currentEnd = 0;    // Current jump'Ä±n ulaÅŸabileceÄŸi son nokta
        int farthest = 0;      // Åimdiye kadar ulaÅŸabildiÄŸimiz en uzak nokta
        
        for (int i = 0; i < nums.Length - 1; i++)
        {
            farthest = Math.Max(farthest, i + nums[i]);
            
            if (i == currentEnd) // Current jump'Ä±n sÄ±nÄ±rÄ±na ulaÅŸtÄ±k
            {
                jumps++;
                currentEnd = farthest; // Yeni jump'la ulaÅŸabileceÄŸimiz nokta
            }
        }
        
        return jumps;
    }
}
```

### 6. Gas Station
**Problem:** Circular route'da tÃ¼m gas station'larÄ± ziyaret edebilir misin?

```csharp
public class GasStation
{
    // Greedy Strategy: Negative balance olursa start noktasÄ±nÄ± deÄŸiÅŸtir
    public int CanCompleteCircuit(int[] gas, int[] cost)
    {
        int totalGas = 0, totalCost = 0;
        int currentGas = 0, startIndex = 0;
        
        for (int i = 0; i < gas.Length; i++)
        {
            totalGas += gas[i];
            totalCost += cost[i];
            currentGas += gas[i] - cost[i];
            
            // Negative olursa bu start point Ã§alÄ±ÅŸmaz
            if (currentGas < 0)
            {
                startIndex = i + 1; // Yeni start point dene
                currentGas = 0;      // Reset
            }
        }
        
        // Total gas yetmiyorsa impossible
        return totalGas >= totalCost ? startIndex : -1;
    }
}
```

## String Greedy Problems

### 7. Remove K Digits
**Problem:** K digit sil, minimum sayÄ±yÄ± elde et

```csharp
public class RemoveKDigits
{
    // Greedy Strategy: Monotonic stack - bÃ¼yÃ¼k digit'i gÃ¶rdÃ¼ÄŸÃ¼nde Ã¶nceki kÃ¼Ã§Ã¼kleri sil
    public string RemoveKdigits(string num, int k)
    {
        Stack<char> stack = new Stack<char>();
        int toRemove = k;
        
        foreach (char digit in num)
        {
            // Stack'teki son digit daha bÃ¼yÃ¼kse ve hala silme hakkÄ±mÄ±z varsa
            while (toRemove > 0 && stack.Count > 0 && stack.Peek() > digit)
            {
                stack.Pop();
                toRemove--;
            }
            
            stack.Push(digit);
        }
        
        // Hala silme hakkÄ±mÄ±z varsa sondan sil
        while (toRemove > 0 && stack.Count > 0)
        {
            stack.Pop();
            toRemove--;
        }
        
        // Result'Ä± oluÅŸtur
        var result = new string(stack.Reverse().ToArray());
        
        // Leading zero'larÄ± temizle
        result = result.TrimStart('0');
        
        return string.IsNullOrEmpty(result) ? "0" : result;
    }
}
```

## Greedy Algorithm'Ä±n DoÄŸruluÄŸunu KanÄ±tlama

### 1. Greedy Choice Property
**"Local optimal choice, global optimal'a gÃ¶tÃ¼rÃ¼r"**

### 2. Optimal Substructure
**"Problem'in optimal solution'Ä±, subproblem'lerin optimal solution'larÄ±nÄ± iÃ§erir"**

### Proof Technique: Exchange Argument
```
1. Optimal solution OPT olsun
2. Greedy'nin ilk choice'Ä± GREEDY olsun  
3. GREEDY â‰  OPT.first ise:
   - OPT'deki first choice'Ä± GREEDY ile deÄŸiÅŸtir
   - Yeni solution OPT'den daha kÃ¶tÃ¼ deÄŸil
   - Contradiction: OPT optimal deÄŸilmiÅŸ
4. SonuÃ§: Greedy choice optimal
```

## Greedy vs DP Decision Matrix

### âœ… Greedy Kullan EÄŸer:
- **Greedy choice property** var
- **Local optimal â†’ global optimal**
- **Simple, fast solution** gerekiyor
- **Matroid structure** var

### âŒ Greedy Kullanma EÄŸer:
- **Overlapping subproblems** var
- **Local optimal â‰  global optimal**
- **Future decisions** Ã¶nceki seÃ§imleri etkiliyor

### Problem Examples:
```
Greedy Works:
âœ… Activity Selection
âœ… Fractional Knapsack  
âœ… Huffman Coding
âœ… Minimum Spanning Tree (Kruskal, Prim)

Greedy Fails:
âŒ 0/1 Knapsack (need DP)
âŒ Longest Common Subsequence (need DP)
âŒ Coin Change (non-standard coins)
```

## Common Greedy Patterns

### 1. Sorting + Greedy
```csharp
// Pattern: Sort by some criteria, then greedy choice
var sorted = items.OrderBy(item => some_criteria);
foreach (var item in sorted) {
    if (can_take(item)) {
        take(item);
    }
}
```

### 2. Two Pointers + Greedy
```csharp
// Pattern: Start from both ends, greedy choice
int left = 0, right = array.Length - 1;
while (left < right) {
    if (some_condition) {
        // Greedy choice
        left++;
    } else {
        right--;
    }
}
```

### 3. Stack + Greedy
```csharp
// Pattern: Monotonic stack for greedy choices
Stack<int> stack = new Stack<int>();
foreach (var item in items) {
    while (stack.Count > 0 && should_remove(stack.Peek(), item)) {
        stack.Pop(); // Greedy removal
    }
    stack.Push(item);
}
```

## Greedy Algorithm Complexity

### Time Complexity:
- Genelde **O(n log n)** (sorting dominant)
- Sometimes **O(n)** (linear scan)

### Space Complexity:
- Genelde **O(1)** (in-place)
- Sometimes **O(n)** (extra data structures)

Greedy algorithms, **simple ve elegant** Ã§Ã¶zÃ¼mler sunar. Trick, **doÄŸru greedy choice**'Ä± bulmak! ğŸ¯ğŸ’š