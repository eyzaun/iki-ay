# Union-Find (Disjoint Set) - Grup Yönetimi Veri Yapısı

## Union-Find Nedir?

Union-Find, **dynamic connectivity** problemlerini çözen veri yapısıdır. **"İki eleman aynı grupta/kümede mi?"** sorusunu neredeyse **O(1)** zamanda cevaplar.

### Gerçek Hayattan Benzetme: Sosyal Ağ
Düşün ki Facebook'ta arkadaşlık ağını yönetiyorsun:
- **Find:** "Ali ile Ayşe aynı arkadaş grubunda mı?"
- **Union:** "Mehmet ile Fatma'nın gruplarını birleştir"
- **Connected:** "Bu iki kişi birbirini tanıyor mu (dolaylı yoldan)?"

### Union-Find'ın 2 Temel Operasyonu:
1. **Find(x):** x'in hangi küme/grupta olduğunu bul
2. **Union(x, y):** x ve y'nin kümelerini birleştir

## Basic Union-Find Implementation

```csharp
public class BasicUnionFind
{
    private int[] parent;    // Her elemanın parent'ı
    private int components;  // Kaç ayrı küme var
    
    public BasicUnionFind(int n)
    {
        parent = new int[n];
        components = n;
        
        // Başlangıçta herkes kendi parent'ı
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
        }
    }
    
    // Find: Root parent'ı bul - O(n) worst case
    public int Find(int x)
    {
        while (parent[x] != x) // Root'a kadar git
        {
            x = parent[x];
        }
        return x;
    }
    
    // Union: İki kümeyi birleştir - O(n) worst case
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX != rootY) // Farklı kümelerden
        {
            parent[rootX] = rootY; // Birini diğerinin altına bağla
            components--;          // Küme sayısı azaldı
        }
    }
    
    // Connected: Aynı kümeде mi?
    public bool Connected(int x, int y)
    {
        return Find(x) == Find(y);
    }
    
    public int ComponentCount => components;
}
```

### Basic Union-Find'ın Problemi:
```
Union işlemleri sırasında tree çok derin olabilir:
1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10
Bu durumda Find(10) = O(n) time alır!
```

## Optimized Union-Find

### 1. Union by Rank/Size
**"Küçük tree'yi büyük tree'nin altına bağla"**

```csharp
public class UnionFindByRank
{
    private int[] parent;
    private int[] rank;    // Tree'nin yüksekliği (yaklaşık)
    private int components;
    
    public UnionFindByRank(int n)
    {
        parent = new int[n];
        rank = new int[n];
        components = n;
        
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            rank[i] = 0; // Başlangıçta hepsi leaf
        }
    }
    
    public int Find(int x)
    {
        while (parent[x] != x)
        {
            x = parent[x];
        }
        return x;
    }
    
    // Union by Rank - daha balanced tree
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return; // Zaten aynı küme
        
        // Rank'ı küçük olanı büyük olanın altına bağla
        if (rank[rootX] < rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else if (rank[rootX] > rank[rootY])
        {
            parent[rootY] = rootX;
        }
        else
        {
            parent[rootY] = rootX;
            rank[rootX]++; // Aynı rank'taysa birinin rank'ını artır
        }
        
        components--;
    }
    
    public bool Connected(int x, int y) => Find(x) == Find(y);
    public int ComponentCount => components;
}
```

### 2. Path Compression
**"Find sırasında tree'yi düzleştir"**

```csharp
public class UnionFindWithPathCompression
{
    private int[] parent;
    private int[] size;
    private int components;
    
    public UnionFindWithPathCompression(int n)
    {
        parent = new int[n];
        size = new int[n];
        components = n;
        
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    // Path Compression: root'a giderken tüm node'ları direkt root'a bağla
    public int Find(int x)
    {
        if (parent[x] != x)
        {
            parent[x] = Find(parent[x]); // Recursive path compression
        }
        return parent[x];
    }
    
    // Union by Size
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return;
        
        // Küçük tree'yi büyük tree'nin altına bağla
        if (size[rootX] < size[rootY])
        {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        }
        else
        {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        }
        
        components--;
    }
    
    public bool Connected(int x, int y) => Find(x) == Find(y);
    public int ComponentCount => components;
    public int GetComponentSize(int x) => size[Find(x)];
}
```

### Path Compression Görsel:
```
Before Find(7):
    1
   / \
  2   5
 /   / \
3   6   8
|   |
4   7

After Find(7) with Path Compression:
    1
   /|\\\
  2 3 4 5 7
       /|\
      6 8
```

## Union-Find Applications

### 1. Number of Islands
**Problem:** 2D grid'de kaç tane island var?

```csharp
public class NumberOfIslands
{
    public int NumIslands(char[,] grid)
    {
        int rows = grid.GetLength(0);
        int cols = grid.GetLength(1);
        
        UnionFind uf = new UnionFind(rows * cols);
        int waterCells = 0;
        
        // Direction vectors for 4-directional movement
        int[] dx = {-1, 1, 0, 0};
        int[] dy = {0, 0, -1, 1};
        
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (grid[i, j] == '1') // Land cell
                {
                    // Check 4 directions
                    for (int d = 0; d < 4; d++)
                    {
                        int ni = i + dx[d];
                        int nj = j + dy[d];
                        
                        if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && 
                            grid[ni, nj] == '1')
                        {
                            int currentCell = i * cols + j;
                            int neighborCell = ni * cols + nj;
                            uf.Union(currentCell, neighborCell);
                        }
                    }
                }
                else
                {
                    waterCells++;
                }
            }
        }
        
        // Total components - water cells = island count
        return uf.ComponentCount - waterCells;
    }
}
```

### 2. Friend Circles / Connected Components
```csharp
public class FriendCircles
{
    // M[i][j] = 1 means person i and j are direct friends
    public int FindCircleNum(int[,] M)
    {
        int n = M.GetLength(0);
        UnionFind uf = new UnionFind(n);
        
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (M[i, j] == 1) // Direct friendship
                {
                    uf.Union(i, j);
                }
            }
        }
        
        return uf.ComponentCount;
    }
}
```

### 3. Accounts Merge
```csharp
public class AccountsMerge
{
    public List<List<string>> AccountsMerge(List<List<string>> accounts)
    {
        UnionFind uf = new UnionFind(accounts.Count);
        Dictionary<string, int> emailToAccount = new Dictionary<string, int>();
        
        // Map emails to account indices
        for (int i = 0; i < accounts.Count; i++)
        {
            for (int j = 1; j < accounts[i].Count; j++) // Skip name at index 0
            {
                string email = accounts[i][j];
                
                if (emailToAccount.ContainsKey(email))
                {
                    // Email already seen, union accounts
                    uf.Union(i, emailToAccount[email]);
                }
                else
                {
                    emailToAccount[email] = i;
                }
            }
        }
        
        // Group emails by root account
        Dictionary<int, List<string>> rootToEmails = new Dictionary<int, List<string>>();
        
        foreach (var kvp in emailToAccount)
        {
            string email = kvp.Key;
            int accountIndex = kvp.Value;
            int root = uf.Find(accountIndex);
            
            if (!rootToEmails.ContainsKey(root))
                rootToEmails[root] = new List<string>();
            
            rootToEmails[root].Add(email);
        }
        
        // Build result
        List<List<string>> result = new List<List<string>>();
        
        foreach (var kvp in rootToEmails)
        {
            int root = kvp.Key;
            List<string> emails = kvp.Value;
            emails.Sort(); // Sort emails
            
            List<string> account = new List<string>();
            account.Add(accounts[root][0]); // Account name
            account.AddRange(emails);
            
            result.Add(account);
        }
        
        return result;
    }
}
```

### 4. Kruskal's Minimum Spanning Tree
```csharp
public class KruskalMST
{
    public class Edge : IComparable<Edge>
    {
        public int From { get; set; }
        public int To { get; set; }
        public int Weight { get; set; }
        
        public int CompareTo(Edge other)
        {
            return Weight.CompareTo(other.Weight);
        }
    }
    
    public List<Edge> KruskalMST(int vertices, List<Edge> edges)
    {
        // Sort edges by weight
        edges.Sort();
        
        UnionFind uf = new UnionFind(vertices);
        List<Edge> mst = new List<Edge>();
        
        foreach (var edge in edges)
        {
            // If adding this edge doesn't create cycle
            if (!uf.Connected(edge.From, edge.To))
            {
                uf.Union(edge.From, edge.To);
                mst.Add(edge);
                
                // MST has exactly V-1 edges
                if (mst.Count == vertices - 1)
                    break;
            }
        }
        
        return mst;
    }
}
```

### 5. Redundant Connection
```csharp
public class RedundantConnection
{
    // Find edge that creates cycle in tree
    public int[] FindRedundantConnection(int[,] edges)
    {
        int n = edges.GetLength(0);
        UnionFind uf = new UnionFind(n + 1); // 1-indexed
        
        for (int i = 0; i < n; i++)
        {
            int u = edges[i, 0];
            int v = edges[i, 1];
            
            if (uf.Connected(u, v))
            {
                // Adding this edge creates cycle
                return new int[] { u, v };
            }
            
            uf.Union(u, v);
        }
        
        return new int[0]; // Should not reach here
    }
}
```

## Dynamic Connectivity with Union-Find

### Online Queries Example
```csharp
public class DynamicConnectivity
{
    private UnionFind uf;
    
    public DynamicConnectivity(int n)
    {
        uf = new UnionFind(n);
    }
    
    public void Connect(int p, int q)
    {
        uf.Union(p, q);
        Console.WriteLine($"Connected {p} and {q}");
    }
    
    public bool IsConnected(int p, int q)
    {
        bool connected = uf.Connected(p, q);
        Console.WriteLine($"{p} and {q} connected: {connected}");
        return connected;
    }
    
    public int GetComponentCount()
    {
        return uf.ComponentCount;
    }
    
    public void PrintStatus()
    {
        Console.WriteLine($"Total components: {uf.ComponentCount}");
    }
}

// Usage example
public void DynamicConnectivityExample()
{
    var dc = new DynamicConnectivity(10);
    
    dc.Connect(4, 3);    // Components: 9
    dc.Connect(3, 8);    // Components: 8
    dc.Connect(6, 5);    // Components: 7
    dc.Connect(9, 4);    // Components: 6
    dc.Connect(2, 1);    // Components: 5
    
    dc.IsConnected(8, 9); // true (8-3-4-9)
    dc.IsConnected(5, 0); // false
    
    dc.Connect(5, 0);    // Components: 4
    dc.Connect(7, 2);    // Components: 3
    dc.Connect(6, 1);    // Components: 2 (connects two large components)
}
```

## Advanced Union-Find Features

### 1. Union-Find with Rollback
```csharp
public class UnionFindWithRollback
{
    private int[] parent;
    private int[] rank;
    private Stack<(int node, int oldParent, int oldRank)> history;
    
    public UnionFindWithRollback(int n)
    {
        parent = new int[n];
        rank = new int[n];
        history = new Stack<(int, int, int)>();
        
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return;
        
        if (rank[rootX] < rank[rootY])
        {
            history.Push((rootX, parent[rootX], rank[rootX]));
            parent[rootX] = rootY;
        }
        else if (rank[rootX] > rank[rootY])
        {
            history.Push((rootY, parent[rootY], rank[rootY]));
            parent[rootY] = rootX;
        }
        else
        {
            history.Push((rootY, parent[rootY], rank[rootY]));
            history.Push((rootX, parent[rootX], rank[rootX]));
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
    
    public void Rollback()
    {
        if (history.Count == 0) return;
        
        var (node, oldParent, oldRank) = history.Pop();
        parent[node] = oldParent;
        rank[node] = oldRank;
    }
    
    // Find without path compression (for rollback compatibility)
    public int Find(int x)
    {
        while (parent[x] != x)
            x = parent[x];
        return x;
    }
}
```

## Union-Find Complexity Analysis

### Time Complexity:
- **Without optimization:** O(n) per operation
- **With Union by Rank:** O(log n) per operation
- **With Path Compression:** Amortized O(α(n)) per operation
- **With both optimizations:** Amortized O(α(n)) per operation

*α(n) = Inverse Ackermann function, neredeyse constant (pratik n için ≤ 5)*

### Space Complexity:
- **O(n)** for parent, rank/size arrays

### Amortized Analysis:
```
Sequence of m operations on n elements:
- Total time: O(m × α(n))
- Average per operation: O(α(n)) ≈ O(1)
```

## Union-Find vs Other Data Structures

| Operation | Union-Find | Graph (Adj List) | Tree |
|-----------|------------|------------------|------|
| **Find Component** | O(α(n)) | O(V+E) | O(log n) |
| **Union/Connect** | O(α(n)) | O(1) | O(log n) |
| **Space** | O(n) | O(V+E) | O(n) |
| **Dynamic** | ✅ | ✅ | Limited |

## Union-Find Use Cases

### ✅ Union-Find Kullan Eğer:
- **Dynamic connectivity** sorguları
- **Connected components** bulma
- **Cycle detection** (undirected graph)
- **MST algorithms** (Kruskal)
- **Percolation** problems
- **Network connectivity** tracking

### ❌ Union-Find Kullanma Eğer:
- **Path queries** gerekiyorsa
- **Disconnection** operations gerekiyorsa
- **Weighted** connectivity (shortest path)
- **Directed graph** problems

Union-Find, **connectivity problemlerinin şampiyonu**! Özellikle **graph algorithms** ve **dynamic systems**'te vazgeçilmez! 🔗⚡

---

## 🎉 Hafta 3 Tamamlandı!

**Öğrendiğin İleri Algoritmalar:**
✅ **Dynamic Programming** - Memoization vs Tabulation  
✅ **Greedy Algorithms** - Local optimal seçimler  
✅ **Heap & Priority Queue** - Öncelik tabanlı işlemler  
✅ **Union-Find** - Dynamic connectivity ve grup yönetimi  

Bu 4 teknik, **algorithm design'ın en güçlü araçları**! Artık karmaşık optimization problemlerini çözebilir, efficient priority systems tasarlayabilir ve dynamic graph problemlerini handle edebilirsin! 🚀🧠