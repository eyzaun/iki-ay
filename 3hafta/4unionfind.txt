# Union-Find (Disjoint Set) - Grup YÃ¶netimi Veri YapÄ±sÄ±

## Union-Find Nedir?

Union-Find, **dynamic connectivity** problemlerini Ã§Ã¶zen veri yapÄ±sÄ±dÄ±r. **"Ä°ki eleman aynÄ± grupta/kÃ¼mede mi?"** sorusunu neredeyse **O(1)** zamanda cevaplar.

### GerÃ§ek Hayattan Benzetme: Sosyal AÄŸ
DÃ¼ÅŸÃ¼n ki Facebook'ta arkadaÅŸlÄ±k aÄŸÄ±nÄ± yÃ¶netiyorsun:
- **Find:** "Ali ile AyÅŸe aynÄ± arkadaÅŸ grubunda mÄ±?"
- **Union:** "Mehmet ile Fatma'nÄ±n gruplarÄ±nÄ± birleÅŸtir"
- **Connected:** "Bu iki kiÅŸi birbirini tanÄ±yor mu (dolaylÄ± yoldan)?"

### Union-Find'Ä±n 2 Temel Operasyonu:
1. **Find(x):** x'in hangi kÃ¼me/grupta olduÄŸunu bul
2. **Union(x, y):** x ve y'nin kÃ¼melerini birleÅŸtir

## Basic Union-Find Implementation

```csharp
public class BasicUnionFind
{
    private int[] parent;    // Her elemanÄ±n parent'Ä±
    private int components;  // KaÃ§ ayrÄ± kÃ¼me var
    
    public BasicUnionFind(int n)
    {
        parent = new int[n];
        components = n;
        
        // BaÅŸlangÄ±Ã§ta herkes kendi parent'Ä±
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
        }
    }
    
    // Find: Root parent'Ä± bul - O(n) worst case
    public int Find(int x)
    {
        while (parent[x] != x) // Root'a kadar git
        {
            x = parent[x];
        }
        return x;
    }
    
    // Union: Ä°ki kÃ¼meyi birleÅŸtir - O(n) worst case
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX != rootY) // FarklÄ± kÃ¼melerden
        {
            parent[rootX] = rootY; // Birini diÄŸerinin altÄ±na baÄŸla
            components--;          // KÃ¼me sayÄ±sÄ± azaldÄ±
        }
    }
    
    // Connected: AynÄ± kÃ¼meĞ´Ğµ mi?
    public bool Connected(int x, int y)
    {
        return Find(x) == Find(y);
    }
    
    public int ComponentCount => components;
}
```

### Basic Union-Find'Ä±n Problemi:
```
Union iÅŸlemleri sÄ±rasÄ±nda tree Ã§ok derin olabilir:
1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10
Bu durumda Find(10) = O(n) time alÄ±r!
```

## Optimized Union-Find

### 1. Union by Rank/Size
**"KÃ¼Ã§Ã¼k tree'yi bÃ¼yÃ¼k tree'nin altÄ±na baÄŸla"**

```csharp
public class UnionFindByRank
{
    private int[] parent;
    private int[] rank;    // Tree'nin yÃ¼ksekliÄŸi (yaklaÅŸÄ±k)
    private int components;
    
    public UnionFindByRank(int n)
    {
        parent = new int[n];
        rank = new int[n];
        components = n;
        
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            rank[i] = 0; // BaÅŸlangÄ±Ã§ta hepsi leaf
        }
    }
    
    public int Find(int x)
    {
        while (parent[x] != x)
        {
            x = parent[x];
        }
        return x;
    }
    
    // Union by Rank - daha balanced tree
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return; // Zaten aynÄ± kÃ¼me
        
        // Rank'Ä± kÃ¼Ã§Ã¼k olanÄ± bÃ¼yÃ¼k olanÄ±n altÄ±na baÄŸla
        if (rank[rootX] < rank[rootY])
        {
            parent[rootX] = rootY;
        }
        else if (rank[rootX] > rank[rootY])
        {
            parent[rootY] = rootX;
        }
        else
        {
            parent[rootY] = rootX;
            rank[rootX]++; // AynÄ± rank'taysa birinin rank'Ä±nÄ± artÄ±r
        }
        
        components--;
    }
    
    public bool Connected(int x, int y) => Find(x) == Find(y);
    public int ComponentCount => components;
}
```

### 2. Path Compression
**"Find sÄ±rasÄ±nda tree'yi dÃ¼zleÅŸtir"**

```csharp
public class UnionFindWithPathCompression
{
    private int[] parent;
    private int[] size;
    private int components;
    
    public UnionFindWithPathCompression(int n)
    {
        parent = new int[n];
        size = new int[n];
        components = n;
        
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    // Path Compression: root'a giderken tÃ¼m node'larÄ± direkt root'a baÄŸla
    public int Find(int x)
    {
        if (parent[x] != x)
        {
            parent[x] = Find(parent[x]); // Recursive path compression
        }
        return parent[x];
    }
    
    // Union by Size
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return;
        
        // KÃ¼Ã§Ã¼k tree'yi bÃ¼yÃ¼k tree'nin altÄ±na baÄŸla
        if (size[rootX] < size[rootY])
        {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        }
        else
        {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        }
        
        components--;
    }
    
    public bool Connected(int x, int y) => Find(x) == Find(y);
    public int ComponentCount => components;
    public int GetComponentSize(int x) => size[Find(x)];
}
```

### Path Compression GÃ¶rsel:
```
Before Find(7):
    1
   / \
  2   5
 /   / \
3   6   8
|   |
4   7

After Find(7) with Path Compression:
    1
   /|\\\
  2 3 4 5 7
       /|\
      6 8
```

## Union-Find Applications

### 1. Number of Islands
**Problem:** 2D grid'de kaÃ§ tane island var?

```csharp
public class NumberOfIslands
{
    public int NumIslands(char[,] grid)
    {
        int rows = grid.GetLength(0);
        int cols = grid.GetLength(1);
        
        UnionFind uf = new UnionFind(rows * cols);
        int waterCells = 0;
        
        // Direction vectors for 4-directional movement
        int[] dx = {-1, 1, 0, 0};
        int[] dy = {0, 0, -1, 1};
        
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (grid[i, j] == '1') // Land cell
                {
                    // Check 4 directions
                    for (int d = 0; d < 4; d++)
                    {
                        int ni = i + dx[d];
                        int nj = j + dy[d];
                        
                        if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && 
                            grid[ni, nj] == '1')
                        {
                            int currentCell = i * cols + j;
                            int neighborCell = ni * cols + nj;
                            uf.Union(currentCell, neighborCell);
                        }
                    }
                }
                else
                {
                    waterCells++;
                }
            }
        }
        
        // Total components - water cells = island count
        return uf.ComponentCount - waterCells;
    }
}
```

### 2. Friend Circles / Connected Components
```csharp
public class FriendCircles
{
    // M[i][j] = 1 means person i and j are direct friends
    public int FindCircleNum(int[,] M)
    {
        int n = M.GetLength(0);
        UnionFind uf = new UnionFind(n);
        
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < n; j++)
            {
                if (M[i, j] == 1) // Direct friendship
                {
                    uf.Union(i, j);
                }
            }
        }
        
        return uf.ComponentCount;
    }
}
```

### 3. Accounts Merge
```csharp
public class AccountsMerge
{
    public List<List<string>> AccountsMerge(List<List<string>> accounts)
    {
        UnionFind uf = new UnionFind(accounts.Count);
        Dictionary<string, int> emailToAccount = new Dictionary<string, int>();
        
        // Map emails to account indices
        for (int i = 0; i < accounts.Count; i++)
        {
            for (int j = 1; j < accounts[i].Count; j++) // Skip name at index 0
            {
                string email = accounts[i][j];
                
                if (emailToAccount.ContainsKey(email))
                {
                    // Email already seen, union accounts
                    uf.Union(i, emailToAccount[email]);
                }
                else
                {
                    emailToAccount[email] = i;
                }
            }
        }
        
        // Group emails by root account
        Dictionary<int, List<string>> rootToEmails = new Dictionary<int, List<string>>();
        
        foreach (var kvp in emailToAccount)
        {
            string email = kvp.Key;
            int accountIndex = kvp.Value;
            int root = uf.Find(accountIndex);
            
            if (!rootToEmails.ContainsKey(root))
                rootToEmails[root] = new List<string>();
            
            rootToEmails[root].Add(email);
        }
        
        // Build result
        List<List<string>> result = new List<List<string>>();
        
        foreach (var kvp in rootToEmails)
        {
            int root = kvp.Key;
            List<string> emails = kvp.Value;
            emails.Sort(); // Sort emails
            
            List<string> account = new List<string>();
            account.Add(accounts[root][0]); // Account name
            account.AddRange(emails);
            
            result.Add(account);
        }
        
        return result;
    }
}
```

### 4. Kruskal's Minimum Spanning Tree
```csharp
public class KruskalMST
{
    public class Edge : IComparable<Edge>
    {
        public int From { get; set; }
        public int To { get; set; }
        public int Weight { get; set; }
        
        public int CompareTo(Edge other)
        {
            return Weight.CompareTo(other.Weight);
        }
    }
    
    public List<Edge> KruskalMST(int vertices, List<Edge> edges)
    {
        // Sort edges by weight
        edges.Sort();
        
        UnionFind uf = new UnionFind(vertices);
        List<Edge> mst = new List<Edge>();
        
        foreach (var edge in edges)
        {
            // If adding this edge doesn't create cycle
            if (!uf.Connected(edge.From, edge.To))
            {
                uf.Union(edge.From, edge.To);
                mst.Add(edge);
                
                // MST has exactly V-1 edges
                if (mst.Count == vertices - 1)
                    break;
            }
        }
        
        return mst;
    }
}
```

### 5. Redundant Connection
```csharp
public class RedundantConnection
{
    // Find edge that creates cycle in tree
    public int[] FindRedundantConnection(int[,] edges)
    {
        int n = edges.GetLength(0);
        UnionFind uf = new UnionFind(n + 1); // 1-indexed
        
        for (int i = 0; i < n; i++)
        {
            int u = edges[i, 0];
            int v = edges[i, 1];
            
            if (uf.Connected(u, v))
            {
                // Adding this edge creates cycle
                return new int[] { u, v };
            }
            
            uf.Union(u, v);
        }
        
        return new int[0]; // Should not reach here
    }
}
```

## Dynamic Connectivity with Union-Find

### Online Queries Example
```csharp
public class DynamicConnectivity
{
    private UnionFind uf;
    
    public DynamicConnectivity(int n)
    {
        uf = new UnionFind(n);
    }
    
    public void Connect(int p, int q)
    {
        uf.Union(p, q);
        Console.WriteLine($"Connected {p} and {q}");
    }
    
    public bool IsConnected(int p, int q)
    {
        bool connected = uf.Connected(p, q);
        Console.WriteLine($"{p} and {q} connected: {connected}");
        return connected;
    }
    
    public int GetComponentCount()
    {
        return uf.ComponentCount;
    }
    
    public void PrintStatus()
    {
        Console.WriteLine($"Total components: {uf.ComponentCount}");
    }
}

// Usage example
public void DynamicConnectivityExample()
{
    var dc = new DynamicConnectivity(10);
    
    dc.Connect(4, 3);    // Components: 9
    dc.Connect(3, 8);    // Components: 8
    dc.Connect(6, 5);    // Components: 7
    dc.Connect(9, 4);    // Components: 6
    dc.Connect(2, 1);    // Components: 5
    
    dc.IsConnected(8, 9); // true (8-3-4-9)
    dc.IsConnected(5, 0); // false
    
    dc.Connect(5, 0);    // Components: 4
    dc.Connect(7, 2);    // Components: 3
    dc.Connect(6, 1);    // Components: 2 (connects two large components)
}
```

## Advanced Union-Find Features

### 1. Union-Find with Rollback
```csharp
public class UnionFindWithRollback
{
    private int[] parent;
    private int[] rank;
    private Stack<(int node, int oldParent, int oldRank)> history;
    
    public UnionFindWithRollback(int n)
    {
        parent = new int[n];
        rank = new int[n];
        history = new Stack<(int, int, int)>();
        
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public void Union(int x, int y)
    {
        int rootX = Find(x);
        int rootY = Find(y);
        
        if (rootX == rootY) return;
        
        if (rank[rootX] < rank[rootY])
        {
            history.Push((rootX, parent[rootX], rank[rootX]));
            parent[rootX] = rootY;
        }
        else if (rank[rootX] > rank[rootY])
        {
            history.Push((rootY, parent[rootY], rank[rootY]));
            parent[rootY] = rootX;
        }
        else
        {
            history.Push((rootY, parent[rootY], rank[rootY]));
            history.Push((rootX, parent[rootX], rank[rootX]));
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
    
    public void Rollback()
    {
        if (history.Count == 0) return;
        
        var (node, oldParent, oldRank) = history.Pop();
        parent[node] = oldParent;
        rank[node] = oldRank;
    }
    
    // Find without path compression (for rollback compatibility)
    public int Find(int x)
    {
        while (parent[x] != x)
            x = parent[x];
        return x;
    }
}
```

## Union-Find Complexity Analysis

### Time Complexity:
- **Without optimization:** O(n) per operation
- **With Union by Rank:** O(log n) per operation
- **With Path Compression:** Amortized O(Î±(n)) per operation
- **With both optimizations:** Amortized O(Î±(n)) per operation

*Î±(n) = Inverse Ackermann function, neredeyse constant (pratik n iÃ§in â‰¤ 5)*

### Space Complexity:
- **O(n)** for parent, rank/size arrays

### Amortized Analysis:
```
Sequence of m operations on n elements:
- Total time: O(m Ã— Î±(n))
- Average per operation: O(Î±(n)) â‰ˆ O(1)
```

## Union-Find vs Other Data Structures

| Operation | Union-Find | Graph (Adj List) | Tree |
|-----------|------------|------------------|------|
| **Find Component** | O(Î±(n)) | O(V+E) | O(log n) |
| **Union/Connect** | O(Î±(n)) | O(1) | O(log n) |
| **Space** | O(n) | O(V+E) | O(n) |
| **Dynamic** | âœ… | âœ… | Limited |

## Union-Find Use Cases

### âœ… Union-Find Kullan EÄŸer:
- **Dynamic connectivity** sorgularÄ±
- **Connected components** bulma
- **Cycle detection** (undirected graph)
- **MST algorithms** (Kruskal)
- **Percolation** problems
- **Network connectivity** tracking

### âŒ Union-Find Kullanma EÄŸer:
- **Path queries** gerekiyorsa
- **Disconnection** operations gerekiyorsa
- **Weighted** connectivity (shortest path)
- **Directed graph** problems

Union-Find, **connectivity problemlerinin ÅŸampiyonu**! Ã–zellikle **graph algorithms** ve **dynamic systems**'te vazgeÃ§ilmez! ğŸ”—âš¡

---

## ğŸ‰ Hafta 3 TamamlandÄ±!

**Ã–ÄŸrendiÄŸin Ä°leri Algoritmalar:**
âœ… **Dynamic Programming** - Memoization vs Tabulation  
âœ… **Greedy Algorithms** - Local optimal seÃ§imler  
âœ… **Heap & Priority Queue** - Ã–ncelik tabanlÄ± iÅŸlemler  
âœ… **Union-Find** - Dynamic connectivity ve grup yÃ¶netimi  

Bu 4 teknik, **algorithm design'Ä±n en gÃ¼Ã§lÃ¼ araÃ§larÄ±**! ArtÄ±k karmaÅŸÄ±k optimization problemlerini Ã§Ã¶zebilir, efficient priority systems tasarlayabilir ve dynamic graph problemlerini handle edebilirsin! ğŸš€ğŸ§ 