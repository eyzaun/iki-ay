# Heap & Priority Queue - Ã–ncelik TabanlÄ± Veri YapÄ±sÄ±

## Heap Nedir?

Heap, **complete binary tree** ÅŸeklinde organize edilmiÅŸ **priority-based** veri yapÄ±sÄ±dÄ±r. **"En Ã¶nemli eleman hep en Ã¼stte"** prensibiyle Ã§alÄ±ÅŸÄ±r.

### GerÃ§ek Hayattan Benzetme: Hastane Acil Servisi
DÃ¼ÅŸÃ¼n ki hastane acil servisinde Ã§alÄ±ÅŸÄ±yorsun:
- **Normal Queue:** Ä°lk gelen ilk tedavi edilir â†’ Adaletsiz
- **Priority Queue (Heap):** En acil hasta Ã¶nce tedavi edilir â†’ Adil ve efficient

### Heap TÃ¼rleri:
1. **Max Heap:** En bÃ¼yÃ¼k eleman root'ta (parent â‰¥ children)
2. **Min Heap:** En kÃ¼Ã§Ã¼k eleman root'ta (parent â‰¤ children)

### Heap vs BST:
```
BST:                    Max Heap:
       50                    90
      /  \                  /  \
    30    70              85    60
   /  \   /  \           /  \   / 
  20  40 60  80        70   30 40

Left < Root < Right    Parent â‰¥ Children (shape matters!)
```

## Heap Properties

### 1. Shape Property
**Complete Binary Tree:** TÃ¼m seviyeler dolu, son seviye soldan dolu

### 2. Heap Property
- **Max Heap:** `parent.value â‰¥ child.value`
- **Min Heap:** `parent.value â‰¤ child.value`

### 3. Array Representation
```csharp
// Heap'i array olarak sakla - Ã§ok efficient!
// Index 0'dan baÅŸlarsak:
// Parent(i) = (i-1)/2
// LeftChild(i) = 2*i + 1  
// RightChild(i) = 2*i + 2

Array: [90, 85, 60, 70, 30, 40]
Tree:
       90 (0)
      /      \
   85(1)    60(2)
   /  \     /
70(3) 30(4) 40(5)
```

## Min Heap Implementation

```csharp
public class MinHeap
{
    private List<int> heap;
    
    public MinHeap()
    {
        heap = new List<int>();
    }
    
    public int Count => heap.Count;
    public bool IsEmpty => heap.Count == 0;
    
    // Helper methods for navigation
    private int GetParentIndex(int childIndex) => (childIndex - 1) / 2;
    private int GetLeftChildIndex(int parentIndex) => 2 * parentIndex + 1;
    private int GetRightChildIndex(int parentIndex) => 2 * parentIndex + 2;
    
    private bool HasParent(int index) => GetParentIndex(index) >= 0;
    private bool HasLeftChild(int index) => GetLeftChildIndex(index) < heap.Count;
    private bool HasRightChild(int index) => GetRightChildIndex(index) < heap.Count;
    
    private int Parent(int index) => heap[GetParentIndex(index)];
    private int LeftChild(int index) => heap[GetLeftChildIndex(index)];
    private int RightChild(int index) => heap[GetRightChildIndex(index)];
    
    // Insert - O(log n)
    public void Insert(int value)
    {
        heap.Add(value);              // Array'in sonuna ekle
        HeapifyUp(heap.Count - 1);    // Heap property'yi restore et
    }
    
    // Extract Min - O(log n)
    public int ExtractMin()
    {
        if (IsEmpty)
            throw new InvalidOperationException("Heap is empty");
        
        int min = heap[0];            // Root'taki minimum
        heap[0] = heap[heap.Count - 1]; // Son elemanÄ± root'a taÅŸÄ±
        heap.RemoveAt(heap.Count - 1); // Son elemanÄ± sil
        
        if (!IsEmpty)
            HeapifyDown(0);           // Heap property'yi restore et
        
        return min;
    }
    
    // Peek - O(1)
    public int Peek()
    {
        if (IsEmpty)
            throw new InvalidOperationException("Heap is empty");
        
        return heap[0]; // Root'taki minimum
    }
    
    // Heapify Up - bubble up
    private void HeapifyUp(int index)
    {
        while (HasParent(index) && Parent(index) > heap[index])
        {
            Swap(GetParentIndex(index), index);
            index = GetParentIndex(index);
        }
    }
    
    // Heapify Down - bubble down
    private void HeapifyDown(int index)
    {
        while (HasLeftChild(index))
        {
            int smallerChildIndex = GetLeftChildIndex(index);
            
            // SaÄŸ Ã§ocuk da varsa ve daha kÃ¼Ã§Ã¼kse
            if (HasRightChild(index) && RightChild(index) < LeftChild(index))
            {
                smallerChildIndex = GetRightChildIndex(index);
            }
            
            // Heap property saÄŸlandÄ±ysa dur
            if (heap[index] <= heap[smallerChildIndex])
                break;
            
            Swap(index, smallerChildIndex);
            index = smallerChildIndex;
        }
    }
    
    private void Swap(int i, int j)
    {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
```

## .NET'te Priority Queue KullanÄ±mÄ±

```csharp
// .NET 6+ built-in PriorityQueue
public class PriorityQueueExample
{
    public void BasicUsage()
    {
        // Min heap (lower number = higher priority)
        var pq = new PriorityQueue<string, int>();
        
        pq.Enqueue("Low priority task", 10);
        pq.Enqueue("High priority task", 1);
        pq.Enqueue("Medium priority task", 5);
        
        while (pq.Count > 0)
        {
            string task = pq.Dequeue();
            Console.WriteLine(task); // High, Medium, Low sÄ±rasÄ±yla
        }
    }
    
    // Custom comparer for max heap
    public void MaxHeapExample()
    {
        var maxHeap = new PriorityQueue<int, int>(
            Comparer<int>.Create((x, y) => y.CompareTo(x)) // Reverse comparison
        );
        
        maxHeap.Enqueue(10, 10);
        maxHeap.Enqueue(30, 30);
        maxHeap.Enqueue(20, 20);
        
        Console.WriteLine(maxHeap.Dequeue()); // 30 (largest first)
    }
    
    // Complex objects
    public void ComplexObjectExample()
    {
        var taskQueue = new PriorityQueue<Task, DateTime>();
        
        taskQueue.Enqueue(new Task("Task A"), DateTime.Now.AddHours(2));
        taskQueue.Enqueue(new Task("Task B"), DateTime.Now.AddHours(1));
        taskQueue.Enqueue(new Task("Task C"), DateTime.Now.AddHours(3));
        
        // En yakÄ±n deadline'lÄ± task Ã¶nce Ã§Ä±kar
        while (taskQueue.Count > 0)
        {
            var nextTask = taskQueue.Dequeue();
            Console.WriteLine($"Execute: {nextTask.Name}");
        }
    }
}
```

## Heap Applications

### 1. Top K Elements
```csharp
public class TopKElements
{
    // Find K largest elements - Min heap kullan
    public List<int> FindKLargest(int[] nums, int k)
    {
        var minHeap = new PriorityQueue<int, int>();
        
        foreach (int num in nums)
        {
            minHeap.Enqueue(num, num);
            
            // Heap size'Ä± k'dan bÃ¼yÃ¼kse en kÃ¼Ã§Ã¼ÄŸÃ¼ Ã§Ä±kar
            if (minHeap.Count > k)
            {
                minHeap.Dequeue(); // En kÃ¼Ã§Ã¼k Ã§Ä±kar
            }
        }
        
        // Heap'te kalan k eleman en bÃ¼yÃ¼k k eleman
        List<int> result = new List<int>();
        while (minHeap.Count > 0)
        {
            result.Add(minHeap.Dequeue());
        }
        
        return result;
    }
    
    // Find K smallest elements - Max heap kullan
    public List<int> FindKSmallest(int[] nums, int k)
    {
        var maxHeap = new PriorityQueue<int, int>(
            Comparer<int>.Create((x, y) => y.CompareTo(x))
        );
        
        foreach (int num in nums)
        {
            maxHeap.Enqueue(num, num);
            
            if (maxHeap.Count > k)
            {
                maxHeap.Dequeue(); // En bÃ¼yÃ¼k Ã§Ä±kar
            }
        }
        
        return maxHeap.UnorderedItems.Select(x => x.Element).ToList();
    }
}
```

### 2. Merge K Sorted Lists
```csharp
public class ListNode
{
    public int val;
    public ListNode next;
    public ListNode(int val = 0, ListNode next = null)
    {
        this.val = val;
        this.next = next;
    }
}

public class MergeKSortedLists
{
    public ListNode MergeKLists(ListNode[] lists)
    {
        var pq = new PriorityQueue<ListNode, int>();
        
        // Her list'in head'ini heap'e ekle
        foreach (var head in lists)
        {
            if (head != null)
                pq.Enqueue(head, head.val);
        }
        
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (pq.Count > 0)
        {
            ListNode smallest = pq.Dequeue();
            current.next = smallest;
            current = current.next;
            
            // Bir sonraki node'u heap'e ekle
            if (smallest.next != null)
            {
                pq.Enqueue(smallest.next, smallest.next.val);
            }
        }
        
        return dummy.next;
    }
}
```

### 3. Task Scheduler
```csharp
public class TaskScheduler
{
    public class Task
    {
        public string Name { get; set; }
        public int Priority { get; set; }
        public DateTime Deadline { get; set; }
        public TimeSpan EstimatedDuration { get; set; }
    }
    
    public List<Task> ScheduleTasks(List<Task> tasks)
    {
        // Earliest Deadline First (EDF) scheduling
        var taskQueue = new PriorityQueue<Task, DateTime>();
        
        foreach (var task in tasks)
        {
            taskQueue.Enqueue(task, task.Deadline);
        }
        
        List<Task> schedule = new List<Task>();
        
        while (taskQueue.Count > 0)
        {
            schedule.Add(taskQueue.Dequeue());
        }
        
        return schedule;
    }
    
    // CPU Scheduling simulation
    public void CPUScheduling()
    {
        var processQueue = new PriorityQueue<Process, int>();
        
        // Processes arrive with different priorities
        processQueue.Enqueue(new Process("P1", 10), 3); // Priority 3
        processQueue.Enqueue(new Process("P2", 5), 1);  // Priority 1 (higher)
        processQueue.Enqueue(new Process("P3", 8), 2);  // Priority 2
        
        Console.WriteLine("CPU Scheduling Order:");
        while (processQueue.Count > 0)
        {
            var process = processQueue.Dequeue();
            Console.WriteLine($"Execute: {process.Name} (Duration: {process.Duration}ms)");
        }
    }
    
    public class Process
    {
        public string Name { get; set; }
        public int Duration { get; set; }
        
        public Process(string name, int duration)
        {
            Name = name;
            Duration = duration;
        }
    }
}
```

### 4. Sliding Window Maximum
```csharp
public class SlidingWindowMaximum
{
    // Using deque (more efficient) but here's heap approach
    public int[] MaxSlidingWindow(int[] nums, int k)
    {
        var maxHeap = new PriorityQueue<(int value, int index), int>(
            Comparer<int>.Create((x, y) => y.CompareTo(x))
        );
        
        List<int> result = new List<int>();
        
        for (int i = 0; i < nums.Length; i++)
        {
            // Add current element
            maxHeap.Enqueue((nums[i], i), nums[i]);
            
            // Remove elements outside window
            while (maxHeap.Count > 0 && maxHeap.Peek().index <= i - k)
            {
                maxHeap.Dequeue();
            }
            
            // Add to result if window is full
            if (i >= k - 1)
            {
                result.Add(maxHeap.Peek().value);
            }
        }
        
        return result.ToArray();
    }
}
```

## Heapify Algorithm

### Build Heap from Array - O(n)
```csharp
public class HeapBuilder
{
    // Build max heap from unsorted array
    public void BuildMaxHeap(int[] array)
    {
        // Start from last non-leaf node ve aÅŸaÄŸÄ± doÄŸru heapify
        int lastNonLeaf = (array.Length / 2) - 1;
        
        for (int i = lastNonLeaf; i >= 0; i--)
        {
            MaxHeapify(array, array.Length, i);
        }
    }
    
    private void MaxHeapify(int[] array, int heapSize, int rootIndex)
    {
        int largest = rootIndex;
        int left = 2 * rootIndex + 1;
        int right = 2 * rootIndex + 2;
        
        // Find largest among root, left child, right child
        if (left < heapSize && array[left] > array[largest])
            largest = left;
        
        if (right < heapSize && array[right] > array[largest])
            largest = right;
        
        // If largest is not root, swap and continue heapifying
        if (largest != rootIndex)
        {
            Swap(array, rootIndex, largest);
            MaxHeapify(array, heapSize, largest);
        }
    }
    
    private void Swap(int[] array, int i, int j)
    {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```

### Heap Sort - O(n log n)
```csharp
public class HeapSort
{
    public void Sort(int[] array)
    {
        // 1. Build max heap
        BuildMaxHeap(array);
        
        // 2. Extract elements one by one
        for (int i = array.Length - 1; i > 0; i--)
        {
            // Move current root to end
            Swap(array, 0, i);
            
            // Heapify reduced heap
            MaxHeapify(array, i, 0);
        }
    }
    
    // Same implementation as HeapBuilder
    private void BuildMaxHeap(int[] array) { /* ... */ }
    private void MaxHeapify(int[] array, int heapSize, int rootIndex) { /* ... */ }
    private void Swap(int[] array, int i, int j) { /* ... */ }
}
```

## Advanced Heap Applications

### 1. Median from Data Stream
```csharp
public class MedianFinder
{
    private PriorityQueue<int, int> maxHeap; // Lower half
    private PriorityQueue<int, int> minHeap; // Upper half
    
    public MedianFinder()
    {
        maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((x, y) => y.CompareTo(x)));
        minHeap = new PriorityQueue<int, int>();
    }
    
    public void AddNum(int num)
    {
        // Add to max heap (lower half)
        maxHeap.Enqueue(num, num);
        
        // Balance: move largest from lower half to upper half
        minHeap.Enqueue(maxHeap.Peek(), maxHeap.Peek());
        maxHeap.Dequeue();
        
        // Ensure maxHeap has equal or one more element
        if (maxHeap.Count < minHeap.Count)
        {
            maxHeap.Enqueue(minHeap.Peek(), minHeap.Peek());
            minHeap.Dequeue();
        }
    }
    
    public double FindMedian()
    {
        if (maxHeap.Count > minHeap.Count)
            return maxHeap.Peek();
        else
            return (maxHeap.Peek() + minHeap.Peek()) / 2.0;
    }
}
```

### 2. Dijkstra's Algorithm (Shortest Path)
```csharp
public class DijkstraAlgorithm
{
    public class Edge
    {
        public int To { get; set; }
        public int Weight { get; set; }
    }
    
    public Dictionary<int, int> FindShortestPaths(Dictionary<int, List<Edge>> graph, int start)
    {
        var distances = new Dictionary<int, int>();
        var pq = new PriorityQueue<int, int>(); // (node, distance)
        
        // Initialize distances
        foreach (var node in graph.Keys)
        {
            distances[node] = int.MaxValue;
        }
        distances[start] = 0;
        
        pq.Enqueue(start, 0);
        
        while (pq.Count > 0)
        {
            int currentNode = pq.Dequeue();
            
            foreach (var edge in graph[currentNode])
            {
                int newDistance = distances[currentNode] + edge.Weight;
                
                if (newDistance < distances[edge.To])
                {
                    distances[edge.To] = newDistance;
                    pq.Enqueue(edge.To, newDistance);
                }
            }
        }
        
        return distances;
    }
}
```

## Heap Complexity Analysis

### Time Complexities:
- **Insert:** O(log n) - Heapify up
- **Extract Min/Max:** O(log n) - Heapify down
- **Peek:** O(1) - Root access
- **Build Heap:** O(n) - Bottom-up heapify
- **Search:** O(n) - Not optimized for search

### Space Complexity:
- **Array-based:** O(1) extra space
- **Pointer-based:** O(n) for tree structure

## Heap vs Other Data Structures

| Operation | Heap | BST | Sorted Array |
|-----------|------|-----|--------------|
| **Find Min/Max** | O(1) | O(log n) | O(1) |
| **Insert** | O(log n) | O(log n) | O(n) |
| **Delete Min/Max** | O(log n) | O(log n) | O(n) |
| **Search** | O(n) | O(log n) | O(log n) |
| **Space** | O(1) extra | O(n) pointers | O(1) extra |

## Heap Use Cases

### âœ… Heap Kullan EÄŸer:
- **Priority queue** gerekiyorsa
- **Top/Bottom K elements** buluyorsan
- **Streaming data**'da min/max tracking
- **Graph algorithms** (Dijkstra, Prim)
- **Scheduling algorithms**

### âŒ Heap Kullanma EÄŸer:
- **Frequent search** operations
- **Sorted order traversal** gerekiyorsa
- **Range queries** yapacaksan
- **Simple FIFO/LIFO** yeterli

Heap, **priority-based** problemlerin vazgeÃ§ilmez aracÄ±! Ã–zellikle **real-time systems** ve **algorithm optimization**'da kritik rol oynar! ðŸ”ï¸âš¡