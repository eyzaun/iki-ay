# Dynamic Programming - Optimization'Ä±n SÃ¼per SilahÄ±

## Dynamic Programming Nedir?

DP, **"aynÄ± alt problemleri tekrar tekrar Ã§Ã¶zmek yerine sonuÃ§larÄ± saklayÄ±p tekrar kullanma"** tekniÄŸidir. **"AkÄ±llÄ± deneme yanÄ±lma"** desek abartmÄ±ÅŸ olmayÄ±z.

### GerÃ§ek Hayattan Benzetme: Matematik SÄ±navÄ±
DÃ¼ÅŸÃ¼n ki Ã§ok zor bir matematik sÄ±navÄ±nda benzer hesaplarÄ± sÃ¼rekli yapÄ±yorsun:
- **Naif yaklaÅŸÄ±m:** Her seferinde aynÄ± hesabÄ± tekrar yap â†’ Ã‡ok yavaÅŸ
- **DP yaklaÅŸÄ±m:** Bir kez hesapla, sonucu not al, sonra tekrar kullan â†’ Ã‡ok hÄ±zlÄ±!

### DP'nin 2 Temel Ã–zelliÄŸi:
1. **Optimal Substructure:** Problemi kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lebilirsin
2. **Overlapping Subproblems:** AynÄ± alt problemler tekrar tekrar Ã§Ä±kÄ±yor

## Fibonacci - DP'yi AnlamanÄ±n En Ä°yi Yolu

### Naive Recursive (Ã‡ok YavaÅŸ - O(2â¿))
```csharp
// Fibonacci naive - Her hesabÄ± tekrar yapÄ±yor!
public int FibonacciNaive(int n)
{
    if (n <= 1) return n;
    
    return FibonacciNaive(n - 1) + FibonacciNaive(n - 2);
    // AynÄ± deÄŸerleri tekrar tekrar hesaplÄ±yor!
}

// Fib(5) hesaplarken:
// Fib(3)'Ã¼ 2 kez, Fib(2)'yi 3 kez, Fib(1)'i 5 kez hesaplÄ±yor!
```

### Memoization - Top Down DP (O(n))
```csharp
// Memoization: HesapladÄ±ÄŸÄ±nÄ± kaydet, tekrar kullan
public class FibonacciMemo
{
    private Dictionary<int, int> memo = new Dictionary<int, int>();
    
    public int Fibonacci(int n)
    {
        if (n <= 1) return n;
        
        if (memo.ContainsKey(n))
            return memo[n]; // Daha Ã¶nce hesapladÄ±k!
        
        memo[n] = Fibonacci(n - 1) + Fibonacci(n - 2);
        return memo[n];
    }
}
```

### Tabulation - Bottom Up DP (O(n))
```csharp
// Tabulation: KÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru table doldur
public int FibonacciTabulation(int n)
{
    if (n <= 1) return n;
    
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++)
    {
        dp[i] = dp[i - 1] + dp[i - 2]; // Ã–nceki sonuÃ§larÄ± kullan
    }
    
    return dp[n];
}

// Space optimized version - O(1) space
public int FibonacciOptimized(int n)
{
    if (n <= 1) return n;
    
    int prev2 = 0, prev1 = 1;
    
    for (int i = 2; i <= n; i++)
    {
        int current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;
}
```

## Memoization vs Tabulation

| Ã–zellik | Memoization (Top-Down) | Tabulation (Bottom-Up) |
|---------|------------------------|------------------------|
| **YaklaÅŸÄ±m** | Recursive + Cache | Iterative + Table |
| **Memory** | Function call stack | Only table |
| **Intuitive** | Daha natural | Daha efficient |
| **Space** | O(n) stack + O(n) table | O(n) table only |
| **Debugging** | Kolay trace | Harder trace |

## Classic DP Problems

### 1. Climbing Stairs
**Problem:** n basamaklÄ± merdiveni Ã§Ä±kmak iÃ§in kaÃ§ farklÄ± yol var? (1 veya 2 adÄ±m atabilirsin)

```csharp
// Memoization version
public class ClimbingStairs
{
    private Dictionary<int, int> memo = new Dictionary<int, int>();
    
    public int ClimbStairs(int n)
    {
        if (n <= 2) return n;
        
        if (memo.ContainsKey(n))
            return memo[n];
        
        memo[n] = ClimbStairs(n - 1) + ClimbStairs(n - 2);
        return memo[n];
    }
    
    // Tabulation version
    public int ClimbStairsTabulation(int n)
    {
        if (n <= 2) return n;
        
        int[] dp = new int[n + 1];
        dp[1] = 1; // 1 basamak: 1 yol
        dp[2] = 2; // 2 basamak: 2 yol
        
        for (int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2]; // Fibonacci pattern!
        }
        
        return dp[n];
    }
}
```

### 2. House Robber
**Problem:** Evleri soyacaksÄ±n ama yan yana 2 evi soyamazsÄ±n. Maximum para ne kadar?

```csharp
public class HouseRobber
{
    // Memoization
    private Dictionary<int, int> memo = new Dictionary<int, int>();
    
    public int Rob(int[] nums)
    {
        return RobHelper(nums, 0);
    }
    
    private int RobHelper(int[] nums, int index)
    {
        if (index >= nums.Length) return 0;
        
        if (memo.ContainsKey(index))
            return memo[index];
        
        // 2 seÃ§enek: Bu evi soy vs soyma
        int robThis = nums[index] + RobHelper(nums, index + 2); // Bu evi soy + 2 sonrakinden devam
        int skipThis = RobHelper(nums, index + 1);              // Bu evi soyma + 1 sonrakinden devam
        
        memo[index] = Math.Max(robThis, skipThis);
        return memo[index];
    }
    
    // Tabulation - daha efficient
    public int RobTabulation(int[] nums)
    {
        if (nums.Length == 0) return 0;
        if (nums.Length == 1) return nums[0];
        
        int[] dp = new int[nums.Length];
        dp[0] = nums[0];                           // Ä°lk ev
        dp[1] = Math.Max(nums[0], nums[1]);        // Ä°lk 2 evden max
        
        for (int i = 2; i < nums.Length; i++)
        {
            dp[i] = Math.Max(
                nums[i] + dp[i - 2],  // Bu evi soy + 2 Ã¶nceki max
                dp[i - 1]             // Bu evi soyma, Ã¶nceki max
            );
        }
        
        return dp[nums.Length - 1];
    }
    
    // Space optimized O(1)
    public int RobOptimized(int[] nums)
    {
        int prev2 = 0, prev1 = 0;
        
        foreach (int num in nums)
        {
            int current = Math.Max(num + prev2, prev1);
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
}
```

### 3. Coin Change
**Problem:** Belirli coinlerle amount'Ä± yapmak iÃ§in minimum coin sayÄ±sÄ±?

```csharp
public class CoinChange
{
    // Memoization
    private Dictionary<int, int> memo = new Dictionary<int, int>();
    
    public int CoinChangeRecursive(int[] coins, int amount)
    {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        
        if (memo.ContainsKey(amount))
            return memo[amount];
        
        int minCoins = int.MaxValue;
        
        foreach (int coin in coins)
        {
            int result = CoinChangeRecursive(coins, amount - coin);
            if (result != -1) // Valid solution
            {
                minCoins = Math.Min(minCoins, result + 1);
            }
        }
        
        memo[amount] = minCoins == int.MaxValue ? -1 : minCoins;
        return memo[amount];
    }
    
    // Tabulation
    public int CoinChangeTabulation(int[] coins, int amount)
    {
        int[] dp = new int[amount + 1];
        Array.Fill(dp, amount + 1); // Impossible value
        dp[0] = 0; // 0 amount iÃ§in 0 coin
        
        for (int i = 1; i <= amount; i++)
        {
            foreach (int coin in coins)
            {
                if (coin <= i) // Coin kullanÄ±labilir
                {
                    dp[i] = Math.Min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

## 2D DP Problems

### Unique Paths
**Problem:** Grid'de sol Ã¼stten saÄŸ alta kaÃ§ farklÄ± yol var? (Sadece saÄŸ/aÅŸaÄŸÄ± hareket)

```csharp
public class UniquePaths
{
    // Memoization
    private Dictionary<string, int> memo = new Dictionary<string, int>();
    
    public int UniquePathsRecursive(int m, int n)
    {
        return PathHelper(0, 0, m, n);
    }
    
    private int PathHelper(int row, int col, int m, int n)
    {
        // Base cases
        if (row >= m || col >= n) return 0; // Out of bounds
        if (row == m - 1 && col == n - 1) return 1; // Reached destination
        
        string key = $"{row},{col}";
        if (memo.ContainsKey(key))
            return memo[key];
        
        memo[key] = PathHelper(row + 1, col, m, n) + // AÅŸaÄŸÄ± git
                    PathHelper(row, col + 1, m, n);   // SaÄŸa git
        
        return memo[key];
    }
    
    // Tabulation
    public int UniquePathsTabulation(int m, int n)
    {
        int[,] dp = new int[m, n];
        
        // Ä°lk satÄ±r ve sÃ¼tunu 1'le doldur (tek yol var)
        for (int i = 0; i < m; i++) dp[i, 0] = 1;
        for (int j = 0; j < n; j++) dp[0, j] = 1;
        
        for (int i = 1; i < m; i++)
        {
            for (int j = 1; j < n; j++)
            {
                dp[i, j] = dp[i - 1, j] + dp[i, j - 1]; // YukarÄ±dan + soldan
            }
        }
        
        return dp[m - 1, n - 1];
    }
}
```

## Subsequence DP Pattern

### Longest Common Subsequence (LCS)
**Problem:** Ä°ki string'in en uzun ortak subsequence'i ne kadar?

```csharp
public class LongestCommonSubsequence
{
    // Memoization
    private Dictionary<string, int> memo = new Dictionary<string, int>();
    
    public int LCSRecursive(string text1, string text2)
    {
        return LCSHelper(text1, text2, 0, 0);
    }
    
    private int LCSHelper(string text1, string text2, int i, int j)
    {
        if (i >= text1.Length || j >= text2.Length) return 0;
        
        string key = $"{i},{j}";
        if (memo.ContainsKey(key))
            return memo[key];
        
        int result;
        if (text1[i] == text2[j])
        {
            result = 1 + LCSHelper(text1, text2, i + 1, j + 1); // Match!
        }
        else
        {
            result = Math.Max(
                LCSHelper(text1, text2, i + 1, j),     // Skip char in text1
                LCSHelper(text1, text2, i, j + 1)      // Skip char in text2
            );
        }
        
        memo[key] = result;
        return result;
    }
    
    // Tabulation
    public int LCSTabulation(string text1, string text2)
    {
        int m = text1.Length, n = text2.Length;
        int[,] dp = new int[m + 1, n + 1];
        
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (text1[i - 1] == text2[j - 1])
                {
                    dp[i, j] = 1 + dp[i - 1, j - 1]; // Characters match
                }
                else
                {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]); // Take max
                }
            }
        }
        
        return dp[m, n];
    }
}
```

## DP Problem Solving Pattern

### 1. Problem'i TanÄ±:
- **Optimization** problem mi? (min/max)
- **Counting** problem mi? (kaÃ§ yol)
- **Decision** problem mi? (possible/impossible)

### 2. State Definition:
```csharp
// dp[i] = "i'de ending optimal solution"
// dp[i][j] = "i,j position'daki optimal solution"
// dp[i][j][k] = "i,j position'da k constraint'le optimal solution"
```

### 3. Recurrence Relation:
```csharp
// Genelde ÅŸu formda:
// dp[i] = Math.Max/Min(dp[i-1] + something, dp[i-2] + something_else)
```

### 4. Base Cases:
```csharp
// dp[0], dp[1] gibi baÅŸlangÄ±Ã§ deÄŸerleri
```

### 5. Answer:
```csharp
// Genelde dp[n-1] veya dp[m][n]
```

## Knapsack Pattern

### 0/1 Knapsack
**Problem:** W capacity'li Ã§antada maximum value ne olur?

```csharp
public class Knapsack
{
    public int KnapsackRecursive(int[] weights, int[] values, int capacity, int index = 0)
    {
        // Base case
        if (index >= weights.Length || capacity <= 0) return 0;
        
        // Item Ã§ok aÄŸÄ±rsa skip et
        if (weights[index] > capacity)
            return KnapsackRecursive(weights, values, capacity, index + 1);
        
        // 2 seÃ§enek: item'i al vs alma
        int include = values[index] + KnapsackRecursive(weights, values, capacity - weights[index], index + 1);
        int exclude = KnapsackRecursive(weights, values, capacity, index + 1);
        
        return Math.Max(include, exclude);
    }
    
    // Tabulation
    public int KnapsackTabulation(int[] weights, int[] values, int capacity)
    {
        int n = weights.Length;
        int[,] dp = new int[n + 1, capacity + 1];
        
        for (int i = 1; i <= n; i++)
        {
            for (int w = 1; w <= capacity; w++)
            {
                if (weights[i - 1] <= w) // Item fits
                {
                    dp[i, w] = Math.Max(
                        values[i - 1] + dp[i - 1, w - weights[i - 1]], // Include item
                        dp[i - 1, w]                                    // Exclude item
                    );
                }
                else
                {
                    dp[i, w] = dp[i - 1, w]; // Can't include, copy previous
                }
            }
        }
        
        return dp[n, capacity];
    }
}
```

## DP Complexity Analysis

### Time Complexity:
- **Memoization:** O(unique states Ã— work per state)
- **Tabulation:** O(state space size)

### Space Complexity:
- **Memoization:** O(recursion depth + memoization table)
- **Tabulation:** O(state space), often optimizable to O(1) or O(n)

## DP vs Greedy vs Divide & Conquer

| Approach | When to Use | Example |
|----------|-------------|---------|
| **DP** | Overlapping subproblems + optimal substructure | Fibonacci, LCS |
| **Greedy** | Local optimal â†’ global optimal | Activity Selection |
| **Divide & Conquer** | Independent subproblems | MergeSort, QuickSort |

## Common DP Mistakes

1. **Wrong state definition:** State tÃ¼m necessary info'yu contain etmeli
2. **Missing base cases:** Edge case'leri handle etmeyi unutma
3. **Wrong recurrence:** Transition logic'i doÄŸru olmalÄ±
4. **Space optimization too early:** Ã–nce correctness, sonra optimization

DP, **problem solving'in en gÃ¼Ã§lÃ¼ araÃ§larÄ±ndan** biri. Pattern'i yakaladÄ±ÄŸÄ±nda Ã§ok karmaÅŸÄ±k problemleri elegant ÅŸekilde Ã§Ã¶zebilirsin! ğŸ§ ğŸ’