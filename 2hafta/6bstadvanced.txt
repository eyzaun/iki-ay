# Binary Search - Advanced Applications

## Binary Search'in GÃ¼cÃ¼

Binary Search sadece **sorted array'de arama** deÄŸil! AslÄ±nda Ã§ok daha gÃ¼Ã§lÃ¼ bir **problem solving technique**. Temel prensibi: **"Search space'i yarÄ±ya bÃ¶l"**.

### GerÃ§ek Hayattan Benzetme: SayÄ± Tahmin Oyunu
DÃ¼ÅŸÃ¼n ki 1-100 arasÄ± sayÄ± tuttum:
- **Naif yaklaÅŸÄ±m:** 1, 2, 3, 4... ÅŸeklinde tek tek dene â†’ O(n)
- **AkÄ±llÄ± yaklaÅŸÄ±m:** 50 de, bÃ¼yÃ¼k mÃ¼ kÃ¼Ã§Ã¼k mÃ¼?, sonra 75 veya 25... â†’ O(log n)

Bu mantÄ±k **sadece sayÄ±larda deÄŸil**, **her monotonic (tek yÃ¶nlÃ¼) problemde** Ã§alÄ±ÅŸÄ±r!

## Klasik Binary Search - Temel

```csharp
// Standart binary search - exact match
public int BinarySearch(int[] array, int target)
{
    int left = 0;
    int right = array.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2; // Overflow prevention
        
        if (array[mid] == target)
            return mid;         // Found!
        else if (array[mid] < target)
            left = mid + 1;     // Search right half
        else
            right = mid - 1;    // Search left half
    }
    
    return -1; // Not found
}
```

## Binary Search Variants

### 1. Lower Bound (Ä°lk Occurrence)
**"Target'Ä±n ilk gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ index"**

```csharp
// Target'Ä±n ilk gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ index'i bul
public int LowerBound(int[] array, int target)
{
    int left = 0;
    int right = array.Length;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (array[mid] < target)
            left = mid + 1;     // Target daha bÃ¼yÃ¼k, saÄŸa git
        else
            right = mid;        // Target â‰¤ array[mid], sol tarafta da olabilir
    }
    
    return left; // Ä°lk valid position
}

// KullanÄ±m Ã¶rneÄŸi: [1, 2, 2, 2, 3, 4], target=2 â†’ return 1
```

### 2. Upper Bound (Son Occurrence + 1)
**"Target'tan bÃ¼yÃ¼k ilk eleman"**

```csharp
// Target'tan bÃ¼yÃ¼k ilk elemanÄ±n index'i
public int UpperBound(int[] array, int target)
{
    int left = 0;
    int right = array.Length;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (array[mid] <= target)
            left = mid + 1;     // Target â‰¥ array[mid], daha saÄŸa bak
        else
            right = mid;        // Target < array[mid], sol tarafÄ± kontrol et
    }
    
    return left;
}

// KullanÄ±m Ã¶rneÄŸi: [1, 2, 2, 2, 3, 4], target=2 â†’ return 4
```

### 3. First and Last Position
```csharp
// Target'Ä±n ilk ve son pozisyonunu bul
public int[] SearchRange(int[] nums, int target)
{
    int first = LowerBound(nums, target);
    
    // Target hiÃ§ yok mu?
    if (first == nums.Length || nums[first] != target)
        return new int[] { -1, -1 };
    
    int last = UpperBound(nums, target) - 1; // Upper bound - 1 = last occurrence
    
    return new int[] { first, last };
}

// Ã–rnek: [5,7,7,8,8,10], target=8 â†’ [3,4]
```

## Advanced Binary Search Applications

### 1. Search in Rotated Sorted Array
**"DÃ¶ndÃ¼rÃ¼lmÃ¼ÅŸ sÄ±ralÄ± array'de arama"**

```csharp
// Rotated sorted array'de arama
public int SearchRotated(int[] nums, int target)
{
    int left = 0;
    int right = nums.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target)
            return mid;
        
        // Sol yarÄ± sorted mÄ±?
        if (nums[left] <= nums[mid])
        {
            // Target sol sorted yarÄ±da mÄ±?
            if (nums[left] <= target && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        }
        else // SaÄŸ yarÄ± sorted
        {
            // Target saÄŸ sorted yarÄ±da mÄ±?
            if (nums[mid] < target && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }
    
    return -1;
}

// Ã–rnek: [4,5,6,7,0,1,2], target=0 â†’ return 4
```

### 2. Find Minimum in Rotated Array
```csharp
// Rotated sorted array'deki minimum
public int FindMin(int[] nums)
{
    int left = 0;
    int right = nums.Length - 1;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        // SaÄŸ yarÄ± unsorted (minimum saÄŸ tarafta)
        if (nums[mid] > nums[right])
            left = mid + 1;
        else
            right = mid; // Minimum sol tarafta veya mid'de
    }
    
    return nums[left];
}
```

### 3. Peak Element
**"KomÅŸularÄ±ndan bÃ¼yÃ¼k olan eleman"**

```csharp
// Peak element bul (komÅŸularÄ±ndan bÃ¼yÃ¼k)
public int FindPeakElement(int[] nums)
{
    int left = 0;
    int right = nums.Length - 1;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        // SaÄŸdaki daha bÃ¼yÃ¼kse, peak saÄŸ tarafta
        if (nums[mid] < nums[mid + 1])
            left = mid + 1;
        else
            right = mid; // Peak sol tarafta veya mid'de
    }
    
    return left;
}

// Ã–rnek: [1,2,3,1] â†’ return 2 (value 3)
```

## Binary Search on Answer Space

**"Cevap uzayÄ±nda binary search"** - En gÃ¼Ã§lÃ¼ teknik!

### 1. Square Root
```csharp
// Integer square root bulma
public int MySqrt(int x)
{
    if (x < 2) return x;
    
    int left = 2;
    int right = x / 2;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        long square = (long)mid * mid; // Overflow prevention
        
        if (square == x)
            return mid;
        else if (square < x)
            left = mid + 1;
        else
            right = mid - 1;
    }
    
    return right; // En bÃ¼yÃ¼k valid answer
}
```

### 2. Capacity To Ship Packages
**"Minimum ship capacity bul"**

```csharp
// Minimum ship capacity - packages'larÄ± D gÃ¼n iÃ§inde gÃ¶nder
public int ShipWithinDays(int[] weights, int D)
{
    int left = weights.Max();        // En aÄŸÄ±r paket (minimum capacity)
    int right = weights.Sum();       // TÃ¼m paketler (maximum capacity)
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (CanShipWithCapacity(weights, D, mid))
            right = mid;      // Bu capacity yeterli, daha kÃ¼Ã§Ã¼k dene
        else
            left = mid + 1;   // Bu capacity yetersiz, bÃ¼yÃ¼t
    }
    
    return left;
}

private bool CanShipWithCapacity(int[] weights, int D, int capacity)
{
    int days = 1;
    int currentWeight = 0;
    
    foreach (int weight in weights)
    {
        if (currentWeight + weight > capacity)
        {
            days++;
            currentWeight = weight;
        }
        else
        {
            currentWeight += weight;
        }
    }
    
    return days <= D;
}
```

### 3. Koko Eating Bananas
```csharp
// Minimum eating speed - H saatte tÃ¼m banana'larÄ± ye
public int MinEatingSpeed(int[] piles, int H)
{
    int left = 1;                    // Minimum speed
    int right = piles.Max();         // Maximum speed (biggest pile)
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (CanFinishInTime(piles, H, mid))
            right = mid;      // Bu hÄ±z yeterli, daha yavaÅŸ dene
        else
            left = mid + 1;   // Bu hÄ±z yetersiz, hÄ±zlan
    }
    
    return left;
}

private bool CanFinishInTime(int[] piles, int H, int speed)
{
    int hours = 0;
    
    foreach (int pile in piles)
    {
        hours += (pile + speed - 1) / speed; // Ceiling division
    }
    
    return hours <= H;
}
```

## 2D Binary Search

### 1. Search 2D Matrix
```csharp
// 2D matrix'te arama (satÄ±r ve sÃ¼tun sorted)
public bool SearchMatrix(int[,] matrix, int target)
{
    int rows = matrix.GetLength(0);
    int cols = matrix.GetLength(1);
    
    // Matrix'i 1D array gibi dÃ¼ÅŸÃ¼n
    int left = 0;
    int right = rows * cols - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        int midValue = matrix[mid / cols, mid % cols]; // 1D index'i 2D'ye Ã§evir
        
        if (midValue == target)
            return true;
        else if (midValue < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    
    return false;
}
```

### 2. Search 2D Matrix II
```csharp
// Her satÄ±r ve sÃ¼tun sorted ama matrix genel olarak sorted deÄŸil
public bool SearchMatrix2(int[,] matrix, int target)
{
    int row = 0;
    int col = matrix.GetLength(1) - 1; // SaÄŸ Ã¼st kÃ¶ÅŸeden baÅŸla
    
    while (row < matrix.GetLength(0) && col >= 0)
    {
        int current = matrix[row, col];
        
        if (current == target)
            return true;
        else if (current > target)
            col--;    // Sol'a git (kÃ¼Ã§Ã¼k deÄŸerler)
        else
            row++;    // AÅŸaÄŸÄ± git (bÃ¼yÃ¼k deÄŸerler)
    }
    
    return false;
}
```

## Binary Search Template Pattern

**Genel binary search template:**

```csharp
public class BinarySearchTemplate
{
    // Template for most binary search problems
    public int BinarySearchTemplate(int[] array, Func<int, bool> condition)
    {
        int left = 0;              // Search space start
        int right = array.Length;  // Search space end (exclusive)
        
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            
            if (condition(mid))
                right = mid;        // Condition true, answer left side
            else
                left = mid + 1;     // Condition false, answer right side
        }
        
        return left; // First position where condition is true
    }
    
    // KullanÄ±m Ã¶rneÄŸi: First position >= target
    public int FindFirstGE(int[] array, int target)
    {
        return BinarySearchTemplate(array, i => array[i] >= target);
    }
}
```

## Binary Search'Ã¼n GerÃ§ek Hayat UygulamalarÄ±

### 1. Database Index
```csharp
// Database'de range query
public class DatabaseIndex
{
    private int[] sortedIds;
    
    public List<int> RangeQuery(int minId, int maxId)
    {
        int startIndex = LowerBound(sortedIds, minId);
        int endIndex = UpperBound(sortedIds, maxId);
        
        List<int> result = new List<int>();
        for (int i = startIndex; i < endIndex; i++)
        {
            result.Add(sortedIds[i]);
        }
        
        return result;
    }
}
```

### 2. Version Control
```csharp
// Git-like version control'de first bad version
public int FirstBadVersion(int n)
{
    int left = 1;
    int right = n;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (IsBadVersion(mid))
            right = mid;      // Bad version, daha erken de olabilir
        else
            left = mid + 1;   // Good version, daha sonrasÄ±nda bad var
    }
    
    return left;
}

private bool IsBadVersion(int version)
{
    // API call to check if version is bad
    return true; // Placeholder
}
```

## Binary Search Complexity

### Time Complexity: **O(log n)**
- Her iterasyonda search space yarÄ±ya iner
- n elemanlÄ± array'de en fazla logâ‚‚(n) adÄ±m

### Space Complexity: **O(1)**
- Iterative implementation sadece birkaÃ§ variable kullanÄ±r
- Recursive implementation O(log n) stack space

## Binary Search Ne Zaman KullanÄ±lÄ±r?

### âœ… Binary Search Kullan EÄŸer:
- **Sorted data** varsa
- **Monotonic** property varsa (tek yÃ¶nlÃ¼ artÄ±ÅŸ/azalÄ±ÅŸ)
- **Answer space** binary search yapÄ±labilirse
- **O(log n)** performance gerekiyorsa
- **Large dataset** ve frequent queries varsa

### ğŸ¯ Binary Search Problem Patterns:
1. **Direct search:** Sorted array'de exact match
2. **Boundary search:** First/last occurrence
3. **Rotated array:** Special sorted array variations
4. **Answer space:** Minimum/maximum value bulma
5. **2D search:** Matrix'te arama

## Advanced Tips

### 1. Overflow Prevention
```csharp
// âŒ YanlÄ±ÅŸ: int overflow olabilir
int mid = (left + right) / 2;

// âœ… DoÄŸru: Overflow'u Ã¶nler
int mid = left + (right - left) / 2;
```

### 2. Boundary Conditions
```csharp
// Template'e gÃ¶re boundary'leri doÄŸru ayarla
int left = 0;
int right = array.Length;     // Exclusive upper bound
// veya
int right = array.Length - 1; // Inclusive upper bound
```

Binary Search, **problem solving'in Ä°sviÃ§re Ã§akÄ±sÄ±** gibi! Sadece arama deÄŸil, **optimization problemlerinde** de Ã§ok gÃ¼Ã§lÃ¼! ğŸ”

---

## ğŸ‰ Hafta 2 TamamlandÄ±!

**Ã–ÄŸrendiÄŸin Konular:**
âœ… **Binary Tree** - AÄŸaÃ§ yapÄ±larÄ±nÄ±n temeli  
âœ… **BST** - SÄ±ralÄ± aÄŸaÃ§ yapÄ±sÄ± ve O(log n) operasyonlar  
âœ… **Tree Traversal** - DFS (preorder, inorder, postorder)  
âœ… **BFS & Graphs** - Level-order traversal ve graph algorithms  
âœ… **Sorting** - MergeSort, QuickSort ve divide & conquer  
âœ… **Binary Search** - Advanced applications ve answer space search  

Bu konular, **algorithm design'Ä±n kalbi**! Åimdi pratik yapmaya baÅŸlayabilirsin! ğŸš€