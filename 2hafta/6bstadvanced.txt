# Binary Search - Advanced Applications

## Binary Search'in Gücü

Binary Search sadece **sorted array'de arama** değil! Aslında çok daha güçlü bir **problem solving technique**. Temel prensibi: **"Search space'i yarıya böl"**.

### Gerçek Hayattan Benzetme: Sayı Tahmin Oyunu
Düşün ki 1-100 arası sayı tuttum:
- **Naif yaklaşım:** 1, 2, 3, 4... şeklinde tek tek dene → O(n)
- **Akıllı yaklaşım:** 50 de, büyük mü küçük mü?, sonra 75 veya 25... → O(log n)

Bu mantık **sadece sayılarda değil**, **her monotonic (tek yönlü) problemde** çalışır!

## Klasik Binary Search - Temel

```csharp
// Standart binary search - exact match
public int BinarySearch(int[] array, int target)
{
    int left = 0;
    int right = array.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2; // Overflow prevention
        
        if (array[mid] == target)
            return mid;         // Found!
        else if (array[mid] < target)
            left = mid + 1;     // Search right half
        else
            right = mid - 1;    // Search left half
    }
    
    return -1; // Not found
}
```

## Binary Search Variants

### 1. Lower Bound (İlk Occurrence)
**"Target'ın ilk görüldüğü index"**

```csharp
// Target'ın ilk görüldüğü index'i bul
public int LowerBound(int[] array, int target)
{
    int left = 0;
    int right = array.Length;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (array[mid] < target)
            left = mid + 1;     // Target daha büyük, sağa git
        else
            right = mid;        // Target ≤ array[mid], sol tarafta da olabilir
    }
    
    return left; // İlk valid position
}

// Kullanım örneği: [1, 2, 2, 2, 3, 4], target=2 → return 1
```

### 2. Upper Bound (Son Occurrence + 1)
**"Target'tan büyük ilk eleman"**

```csharp
// Target'tan büyük ilk elemanın index'i
public int UpperBound(int[] array, int target)
{
    int left = 0;
    int right = array.Length;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (array[mid] <= target)
            left = mid + 1;     // Target ≥ array[mid], daha sağa bak
        else
            right = mid;        // Target < array[mid], sol tarafı kontrol et
    }
    
    return left;
}

// Kullanım örneği: [1, 2, 2, 2, 3, 4], target=2 → return 4
```

### 3. First and Last Position
```csharp
// Target'ın ilk ve son pozisyonunu bul
public int[] SearchRange(int[] nums, int target)
{
    int first = LowerBound(nums, target);
    
    // Target hiç yok mu?
    if (first == nums.Length || nums[first] != target)
        return new int[] { -1, -1 };
    
    int last = UpperBound(nums, target) - 1; // Upper bound - 1 = last occurrence
    
    return new int[] { first, last };
}

// Örnek: [5,7,7,8,8,10], target=8 → [3,4]
```

## Advanced Binary Search Applications

### 1. Search in Rotated Sorted Array
**"Döndürülmüş sıralı array'de arama"**

```csharp
// Rotated sorted array'de arama
public int SearchRotated(int[] nums, int target)
{
    int left = 0;
    int right = nums.Length - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target)
            return mid;
        
        // Sol yarı sorted mı?
        if (nums[left] <= nums[mid])
        {
            // Target sol sorted yarıda mı?
            if (nums[left] <= target && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        }
        else // Sağ yarı sorted
        {
            // Target sağ sorted yarıda mı?
            if (nums[mid] < target && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        }
    }
    
    return -1;
}

// Örnek: [4,5,6,7,0,1,2], target=0 → return 4
```

### 2. Find Minimum in Rotated Array
```csharp
// Rotated sorted array'deki minimum
public int FindMin(int[] nums)
{
    int left = 0;
    int right = nums.Length - 1;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        // Sağ yarı unsorted (minimum sağ tarafta)
        if (nums[mid] > nums[right])
            left = mid + 1;
        else
            right = mid; // Minimum sol tarafta veya mid'de
    }
    
    return nums[left];
}
```

### 3. Peak Element
**"Komşularından büyük olan eleman"**

```csharp
// Peak element bul (komşularından büyük)
public int FindPeakElement(int[] nums)
{
    int left = 0;
    int right = nums.Length - 1;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        // Sağdaki daha büyükse, peak sağ tarafta
        if (nums[mid] < nums[mid + 1])
            left = mid + 1;
        else
            right = mid; // Peak sol tarafta veya mid'de
    }
    
    return left;
}

// Örnek: [1,2,3,1] → return 2 (value 3)
```

## Binary Search on Answer Space

**"Cevap uzayında binary search"** - En güçlü teknik!

### 1. Square Root
```csharp
// Integer square root bulma
public int MySqrt(int x)
{
    if (x < 2) return x;
    
    int left = 2;
    int right = x / 2;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        long square = (long)mid * mid; // Overflow prevention
        
        if (square == x)
            return mid;
        else if (square < x)
            left = mid + 1;
        else
            right = mid - 1;
    }
    
    return right; // En büyük valid answer
}
```

### 2. Capacity To Ship Packages
**"Minimum ship capacity bul"**

```csharp
// Minimum ship capacity - packages'ları D gün içinde gönder
public int ShipWithinDays(int[] weights, int D)
{
    int left = weights.Max();        // En ağır paket (minimum capacity)
    int right = weights.Sum();       // Tüm paketler (maximum capacity)
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (CanShipWithCapacity(weights, D, mid))
            right = mid;      // Bu capacity yeterli, daha küçük dene
        else
            left = mid + 1;   // Bu capacity yetersiz, büyüt
    }
    
    return left;
}

private bool CanShipWithCapacity(int[] weights, int D, int capacity)
{
    int days = 1;
    int currentWeight = 0;
    
    foreach (int weight in weights)
    {
        if (currentWeight + weight > capacity)
        {
            days++;
            currentWeight = weight;
        }
        else
        {
            currentWeight += weight;
        }
    }
    
    return days <= D;
}
```

### 3. Koko Eating Bananas
```csharp
// Minimum eating speed - H saatte tüm banana'ları ye
public int MinEatingSpeed(int[] piles, int H)
{
    int left = 1;                    // Minimum speed
    int right = piles.Max();         // Maximum speed (biggest pile)
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (CanFinishInTime(piles, H, mid))
            right = mid;      // Bu hız yeterli, daha yavaş dene
        else
            left = mid + 1;   // Bu hız yetersiz, hızlan
    }
    
    return left;
}

private bool CanFinishInTime(int[] piles, int H, int speed)
{
    int hours = 0;
    
    foreach (int pile in piles)
    {
        hours += (pile + speed - 1) / speed; // Ceiling division
    }
    
    return hours <= H;
}
```

## 2D Binary Search

### 1. Search 2D Matrix
```csharp
// 2D matrix'te arama (satır ve sütun sorted)
public bool SearchMatrix(int[,] matrix, int target)
{
    int rows = matrix.GetLength(0);
    int cols = matrix.GetLength(1);
    
    // Matrix'i 1D array gibi düşün
    int left = 0;
    int right = rows * cols - 1;
    
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        int midValue = matrix[mid / cols, mid % cols]; // 1D index'i 2D'ye çevir
        
        if (midValue == target)
            return true;
        else if (midValue < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    
    return false;
}
```

### 2. Search 2D Matrix II
```csharp
// Her satır ve sütun sorted ama matrix genel olarak sorted değil
public bool SearchMatrix2(int[,] matrix, int target)
{
    int row = 0;
    int col = matrix.GetLength(1) - 1; // Sağ üst köşeden başla
    
    while (row < matrix.GetLength(0) && col >= 0)
    {
        int current = matrix[row, col];
        
        if (current == target)
            return true;
        else if (current > target)
            col--;    // Sol'a git (küçük değerler)
        else
            row++;    // Aşağı git (büyük değerler)
    }
    
    return false;
}
```

## Binary Search Template Pattern

**Genel binary search template:**

```csharp
public class BinarySearchTemplate
{
    // Template for most binary search problems
    public int BinarySearchTemplate(int[] array, Func<int, bool> condition)
    {
        int left = 0;              // Search space start
        int right = array.Length;  // Search space end (exclusive)
        
        while (left < right)
        {
            int mid = left + (right - left) / 2;
            
            if (condition(mid))
                right = mid;        // Condition true, answer left side
            else
                left = mid + 1;     // Condition false, answer right side
        }
        
        return left; // First position where condition is true
    }
    
    // Kullanım örneği: First position >= target
    public int FindFirstGE(int[] array, int target)
    {
        return BinarySearchTemplate(array, i => array[i] >= target);
    }
}
```

## Binary Search'ün Gerçek Hayat Uygulamaları

### 1. Database Index
```csharp
// Database'de range query
public class DatabaseIndex
{
    private int[] sortedIds;
    
    public List<int> RangeQuery(int minId, int maxId)
    {
        int startIndex = LowerBound(sortedIds, minId);
        int endIndex = UpperBound(sortedIds, maxId);
        
        List<int> result = new List<int>();
        for (int i = startIndex; i < endIndex; i++)
        {
            result.Add(sortedIds[i]);
        }
        
        return result;
    }
}
```

### 2. Version Control
```csharp
// Git-like version control'de first bad version
public int FirstBadVersion(int n)
{
    int left = 1;
    int right = n;
    
    while (left < right)
    {
        int mid = left + (right - left) / 2;
        
        if (IsBadVersion(mid))
            right = mid;      // Bad version, daha erken de olabilir
        else
            left = mid + 1;   // Good version, daha sonrasında bad var
    }
    
    return left;
}

private bool IsBadVersion(int version)
{
    // API call to check if version is bad
    return true; // Placeholder
}
```

## Binary Search Complexity

### Time Complexity: **O(log n)**
- Her iterasyonda search space yarıya iner
- n elemanlı array'de en fazla log₂(n) adım

### Space Complexity: **O(1)**
- Iterative implementation sadece birkaç variable kullanır
- Recursive implementation O(log n) stack space

## Binary Search Ne Zaman Kullanılır?

### ✅ Binary Search Kullan Eğer:
- **Sorted data** varsa
- **Monotonic** property varsa (tek yönlü artış/azalış)
- **Answer space** binary search yapılabilirse
- **O(log n)** performance gerekiyorsa
- **Large dataset** ve frequent queries varsa

### 🎯 Binary Search Problem Patterns:
1. **Direct search:** Sorted array'de exact match
2. **Boundary search:** First/last occurrence
3. **Rotated array:** Special sorted array variations
4. **Answer space:** Minimum/maximum value bulma
5. **2D search:** Matrix'te arama

## Advanced Tips

### 1. Overflow Prevention
```csharp
// ❌ Yanlış: int overflow olabilir
int mid = (left + right) / 2;

// ✅ Doğru: Overflow'u önler
int mid = left + (right - left) / 2;
```

### 2. Boundary Conditions
```csharp
// Template'e göre boundary'leri doğru ayarla
int left = 0;
int right = array.Length;     // Exclusive upper bound
// veya
int right = array.Length - 1; // Inclusive upper bound
```

Binary Search, **problem solving'in İsviçre çakısı** gibi! Sadece arama değil, **optimization problemlerinde** de çok güçlü! 🔍

---

## 🎉 Hafta 2 Tamamlandı!

**Öğrendiğin Konular:**
✅ **Binary Tree** - Ağaç yapılarının temeli  
✅ **BST** - Sıralı ağaç yapısı ve O(log n) operasyonlar  
✅ **Tree Traversal** - DFS (preorder, inorder, postorder)  
✅ **BFS & Graphs** - Level-order traversal ve graph algorithms  
✅ **Sorting** - MergeSort, QuickSort ve divide & conquer  
✅ **Binary Search** - Advanced applications ve answer space search  

Bu konular, **algorithm design'ın kalbi**! Şimdi pratik yapmaya başlayabilirsin! 🚀