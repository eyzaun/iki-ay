# Binary Search Tree (BST) - SÄ±ralÄ± AÄŸaÃ§ YapÄ±sÄ±

## BST Nedir? Binary Tree'den FarkÄ± Ne?

BST, **Ã¶zel kurallÄ± Binary Tree** gibi dÃ¼ÅŸÃ¼n. Her node iÃ§in:
- **Sol Ã§ocuk < Parent**
- **SaÄŸ Ã§ocuk > Parent**

Bu basit kural, **O(log n) arama** sÃ¼per gÃ¼cÃ¼ verir!

### GerÃ§ek Hayattan Benzetme: KÃ¼tÃ¼phane Sistemi
DÃ¼ÅŸÃ¼n ki Ã§ok akÄ±llÄ± bir kÃ¼tÃ¼phaneci var:
- **Sol rafa** senden **kÃ¼Ã§Ã¼k numaralÄ±** kitaplarÄ± koyuyor
- **SaÄŸ rafa** senden **bÃ¼yÃ¼k numaralÄ±** kitaplarÄ± koyuyor
- Her rafta da **aynÄ± sistem** devam ediyor

Bu sayede istediÄŸin kitabÄ± Ã§ok hÄ±zlÄ± bulabiliyorsun!

```
Ã–rnek BST:
       50
      /  \
    30    70
   /  \   /  \
  20  40 60  80

Left < Root < Right kuralÄ± her yerde geÃ§erli!
```

## BST'nin Sihirli GÃ¼cÃ¼: Sorted Order

BST'nin en bÃ¼yÃ¼k avantajÄ±: **Inorder traversal ile sÄ±ralÄ± liste** elde edersin!

```
YukarÄ±daki BST'nin inorder traversal'Ä±: 20, 30, 40, 50, 60, 70, 80
â†’ Otomatik olarak sÄ±ralÄ±! ğŸ¯
```

## BST Node Implementation

```csharp
public class BSTNode
{
    public int Val { get; set; }
    public BSTNode Left { get; set; }
    public BSTNode Right { get; set; }
    
    public BSTNode(int val)
    {
        Val = val;
        Left = null;
        Right = null;
    }
}

public class BinarySearchTree
{
    public BSTNode Root { get; set; }
    
    public BinarySearchTree()
    {
        Root = null;
    }
}
```

## BST Temel Ä°ÅŸlemleri

### 1. Search (Arama) - O(log n) âš¡

```csharp
// BST'de deÄŸer arama - Ã§ok hÄ±zlÄ±!
public bool Search(BSTNode root, int target)
{
    if (root == null) return false;
    
    if (root.Val == target) 
        return true; // Bulundu!
    
    if (target < root.Val)
        return Search(root.Left, target);  // Sol tarafa git
    else
        return Search(root.Right, target); // SaÄŸ tarafa git
}

// Iterative version - daha memory efficient
public bool SearchIterative(int target)
{
    BSTNode current = Root;
    
    while (current != null)
    {
        if (current.Val == target)
            return true;
        
        if (target < current.Val)
            current = current.Left;
        else
            current = current.Right;
    }
    
    return false;
}
```

### 2. Insert (Ekleme) - O(log n) âš¡

```csharp
// BST'ye yeni deÄŸer ekleme
public BSTNode Insert(BSTNode root, int val)
{
    // Base case: boÅŸ yer buldu, yeni node oluÅŸtur
    if (root == null)
        return new BSTNode(val);
    
    if (val < root.Val)
        root.Left = Insert(root.Left, val);   // Sol tarafa ekle
    else if (val > root.Val)
        root.Right = Insert(root.Right, val); // SaÄŸ tarafa ekle
    // val == root.Val durumunda ekleme (duplicate'leri ignore et)
    
    return root;
}

// Public method
public void Insert(int val)
{
    Root = Insert(Root, val);
}
```

### 3. Min/Max Bulma - O(log n) âš¡

```csharp
// En kÃ¼Ã§Ã¼k deÄŸer - en soldaki node
public int FindMin(BSTNode root)
{
    if (root == null)
        throw new InvalidOperationException("Tree boÅŸ!");
    
    while (root.Left != null)
        root = root.Left;
    
    return root.Val;
}

// En bÃ¼yÃ¼k deÄŸer - en saÄŸdaki node  
public int FindMax(BSTNode root)
{
    if (root == null)
        throw new InvalidOperationException("Tree boÅŸ!");
    
    while (root.Right != null)
        root = root.Right;
    
    return root.Val;
}
```

### 4. Delete (Silme) - O(log n) ğŸ¤”

Bu en karmaÅŸÄ±k iÅŸlem! 3 durum var:

```csharp
public BSTNode Delete(BSTNode root, int val)
{
    if (root == null) return null; // DeÄŸer bulunamadÄ±
    
    if (val < root.Val)
        root.Left = Delete(root.Left, val);
    else if (val > root.Val)
        root.Right = Delete(root.Right, val);
    else // val == root.Val, silinecek node bulundu!
    {
        // Case 1: Leaf node (Ã§ocuk yok)
        if (root.Left == null && root.Right == null)
            return null;
        
        // Case 2: Tek Ã§ocuk var
        if (root.Left == null)
            return root.Right;
        if (root.Right == null)
            return root.Left;
        
        // Case 3: Ä°ki Ã§ocuk var - en karmaÅŸÄ±k durum!
        // SaÄŸ alt aÄŸaÃ§taki en kÃ¼Ã§Ã¼k deÄŸeri bul (inorder successor)
        int minVal = FindMin(root.Right);
        root.Val = minVal; // Current node'un deÄŸerini deÄŸiÅŸtir
        root.Right = Delete(root.Right, minVal); // Successor'Ä± sil
    }
    
    return root;
}
```

### Silme Ä°ÅŸleminin GÃ¶rsel AÃ§Ä±klamasÄ±:
```
Silme Case 3 Ã¶rneÄŸi:
       50
      /  \
    30    70    â† 50'yi silmek istiyoruz
   /  \   /  \
  20  40 60  80

AdÄ±mlar:
1. 50'nin saÄŸ alt aÄŸacÄ±ndaki en kÃ¼Ã§Ã¼k: 60
2. 50'yi 60 ile deÄŸiÅŸtir
3. 60'Ä± orijinal yerinden sil

SonuÃ§:
       60
      /  \
    30    70
   /  \    \
  20  40   80
```

## BST Traversal ve SÄ±ralama

### Inorder Traversal = SÄ±ralÄ± Liste!
```csharp
// Inorder: Left â†’ Root â†’ Right
public void InorderTraversal(BSTNode root, List<int> result)
{
    if (root == null) return;
    
    InorderTraversal(root.Left, result);   // Sol
    result.Add(root.Val);                  // Root
    InorderTraversal(root.Right, result);  // SaÄŸ
}

// BST'deki tÃ¼m elemanlarÄ± sÄ±ralÄ± ÅŸekilde al
public List<int> GetSortedElements()
{
    List<int> result = new List<int>();
    InorderTraversal(Root, result);
    return result; // Otomatik olarak sÄ±ralÄ±!
}
```

### BST'den Range Query
```csharp
// Belirli aralÄ±ktaki deÄŸerleri bul
public List<int> RangeQuery(BSTNode root, int min, int max)
{
    List<int> result = new List<int>();
    RangeQueryHelper(root, min, max, result);
    return result;
}

private void RangeQueryHelper(BSTNode root, int min, int max, List<int> result)
{
    if (root == null) return;
    
    // Current value aralÄ±kta mÄ±?
    if (root.Val >= min && root.Val <= max)
        result.Add(root.Val);
    
    // Sol alt aÄŸaca git (eÄŸer mantÄ±klÄ±ysa)
    if (root.Val > min)
        RangeQueryHelper(root.Left, min, max, result);
    
    // SaÄŸ alt aÄŸaca git (eÄŸer mantÄ±klÄ±ysa)
    if (root.Val < max)
        RangeQueryHelper(root.Right, min, max, result);
}
```

## BST Validation (DoÄŸrulama)

Bir tree'nin gerÃ§ekten BST olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek:

```csharp
// BST property'sini kontrol et
public bool IsValidBST(BSTNode root)
{
    return IsValidBSTHelper(root, int.MinValue, int.MaxValue);
}

private bool IsValidBSTHelper(BSTNode root, int min, int max)
{
    if (root == null) return true;
    
    // Current node sÄ±nÄ±rlar iÃ§inde mi?
    if (root.Val <= min || root.Val >= max)
        return false;
    
    // Sol alt aÄŸaÃ§: Ã¼st sÄ±nÄ±r current value
    // SaÄŸ alt aÄŸaÃ§: alt sÄ±nÄ±r current value
    return IsValidBSTHelper(root.Left, min, root.Val) &&
           IsValidBSTHelper(root.Right, root.Val, max);
}
```

## BST'nin GerÃ§ek Hayat UygulamalarÄ±

### 1. Database Index
```csharp
// Database'deki kayÄ±tlarÄ± hÄ±zlÄ± arama iÃ§in
public class DatabaseIndex
{
    private BSTNode root;
    
    public void AddRecord(int id)
    {
        root = Insert(root, id);
    }
    
    public bool RecordExists(int id)
    {
        return Search(root, id); // O(log n) arama!
    }
}
```

### 2. Auto-complete System
```csharp
// String BST for auto-complete
public class AutoComplete
{
    public class StringBSTNode
    {
        public string Word { get; set; }
        public StringBSTNode Left { get; set; }
        public StringBSTNode Right { get; set; }
        
        public StringBSTNode(string word)
        {
            Word = word;
        }
    }
    
    private StringBSTNode root;
    
    public void AddWord(string word)
    {
        root = InsertString(root, word);
    }
    
    private StringBSTNode InsertString(StringBSTNode root, string word)
    {
        if (root == null)
            return new StringBSTNode(word);
        
        if (string.Compare(word, root.Word) < 0)
            root.Left = InsertString(root.Left, word);
        else if (string.Compare(word, root.Word) > 0)
            root.Right = InsertString(root.Right, word);
        
        return root;
    }
}
```

## BST Performance Analizi

### âš¡ Best Case (Balanced Tree):
- **Search:** O(log n)
- **Insert:** O(log n)
- **Delete:** O(log n)
- **Min/Max:** O(log n)

### ğŸŒ Worst Case (Degenerate Tree):
```
Degenerate BST (LinkedList gibi):
1
 \
  2
   \
    3
     \
      4

TÃ¼m operasyonlar O(n) olur!
```

### ğŸ¯ BST'yi Balanced Tutma:
Bu durumda **AVL Tree** veya **Red-Black Tree** kullanÄ±lÄ±r (self-balancing).

## BST vs DiÄŸer Veri YapÄ±larÄ±

| Ã–zellik | Array (Sorted) | HashMap | BST |
|---------|---------------|---------|-----|
| **Search** | O(log n) | O(1) avg | O(log n) |
| **Insert** | O(n) | O(1) avg | O(log n) |
| **Sorted order** | Manual | âŒ | Otomatik âœ… |
| **Range query** | O(log n + k) | O(n) | O(log n + k) |
| **Memory** | Compact | Extra | Extra |

## BST Ne Zaman KullanÄ±lÄ±r?

### âœ… BST Kullan EÄŸer:
- **Sorted order** Ã¶nemliyse
- **Range queries** yapacaksan
- **Minimum/Maximum** sÄ±k bulacaksan
- **Dynamic dataset** ve sÄ±ralama gerekiyorsa
- **Predecessor/Successor** bulma gerekiyorsa

### âŒ BST Kullanma EÄŸer:
- **Only key lookup** gerekiyorsa (HashMap kullan)
- **Fixed dataset** (Sorted array kullan)
- **Memory critical** (Array daha efficient)
- **Worst case guarantee** gerekiyorsa (Balanced BST kullan)

## Advanced BST Concepts

### 1. Kth Smallest Element
```csharp
// BST'deki k'Ä±ncÄ± en kÃ¼Ã§Ã¼k elemanÄ± bul
public int KthSmallest(BSTNode root, int k)
{
    int count = 0;
    return KthSmallestHelper(root, k, ref count);
}

private int KthSmallestHelper(BSTNode root, int k, ref int count)
{
    if (root == null) return -1;
    
    // Sol alt aÄŸaÃ§ta ara
    int leftResult = KthSmallestHelper(root.Left, k, ref count);
    if (leftResult != -1) return leftResult;
    
    // Current node
    count++;
    if (count == k) return root.Val;
    
    // SaÄŸ alt aÄŸaÃ§ta ara
    return KthSmallestHelper(root.Right, k, ref count);
}
```

BST, sorting ve searching problemlerinin elegant Ã§Ã¶zÃ¼mÃ¼! Next: Tree Traversal teknikleri ğŸŒ²