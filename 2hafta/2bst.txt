# Binary Search Tree (BST) - Sıralı Ağaç Yapısı

## BST Nedir? Binary Tree'den Farkı Ne?

BST, **özel kurallı Binary Tree** gibi düşün. Her node için:
- **Sol çocuk < Parent**
- **Sağ çocuk > Parent**

Bu basit kural, **O(log n) arama** süper gücü verir!

### Gerçek Hayattan Benzetme: Kütüphane Sistemi
Düşün ki çok akıllı bir kütüphaneci var:
- **Sol rafa** senden **küçük numaralı** kitapları koyuyor
- **Sağ rafa** senden **büyük numaralı** kitapları koyuyor
- Her rafta da **aynı sistem** devam ediyor

Bu sayede istediğin kitabı çok hızlı bulabiliyorsun!

```
Örnek BST:
       50
      /  \
    30    70
   /  \   /  \
  20  40 60  80

Left < Root < Right kuralı her yerde geçerli!
```

## BST'nin Sihirli Gücü: Sorted Order

BST'nin en büyük avantajı: **Inorder traversal ile sıralı liste** elde edersin!

```
Yukarıdaki BST'nin inorder traversal'ı: 20, 30, 40, 50, 60, 70, 80
→ Otomatik olarak sıralı! 🎯
```

## BST Node Implementation

```csharp
public class BSTNode
{
    public int Val { get; set; }
    public BSTNode Left { get; set; }
    public BSTNode Right { get; set; }
    
    public BSTNode(int val)
    {
        Val = val;
        Left = null;
        Right = null;
    }
}

public class BinarySearchTree
{
    public BSTNode Root { get; set; }
    
    public BinarySearchTree()
    {
        Root = null;
    }
}
```

## BST Temel İşlemleri

### 1. Search (Arama) - O(log n) ⚡

```csharp
// BST'de değer arama - çok hızlı!
public bool Search(BSTNode root, int target)
{
    if (root == null) return false;
    
    if (root.Val == target) 
        return true; // Bulundu!
    
    if (target < root.Val)
        return Search(root.Left, target);  // Sol tarafa git
    else
        return Search(root.Right, target); // Sağ tarafa git
}

// Iterative version - daha memory efficient
public bool SearchIterative(int target)
{
    BSTNode current = Root;
    
    while (current != null)
    {
        if (current.Val == target)
            return true;
        
        if (target < current.Val)
            current = current.Left;
        else
            current = current.Right;
    }
    
    return false;
}
```

### 2. Insert (Ekleme) - O(log n) ⚡

```csharp
// BST'ye yeni değer ekleme
public BSTNode Insert(BSTNode root, int val)
{
    // Base case: boş yer buldu, yeni node oluştur
    if (root == null)
        return new BSTNode(val);
    
    if (val < root.Val)
        root.Left = Insert(root.Left, val);   // Sol tarafa ekle
    else if (val > root.Val)
        root.Right = Insert(root.Right, val); // Sağ tarafa ekle
    // val == root.Val durumunda ekleme (duplicate'leri ignore et)
    
    return root;
}

// Public method
public void Insert(int val)
{
    Root = Insert(Root, val);
}
```

### 3. Min/Max Bulma - O(log n) ⚡

```csharp
// En küçük değer - en soldaki node
public int FindMin(BSTNode root)
{
    if (root == null)
        throw new InvalidOperationException("Tree boş!");
    
    while (root.Left != null)
        root = root.Left;
    
    return root.Val;
}

// En büyük değer - en sağdaki node  
public int FindMax(BSTNode root)
{
    if (root == null)
        throw new InvalidOperationException("Tree boş!");
    
    while (root.Right != null)
        root = root.Right;
    
    return root.Val;
}
```

### 4. Delete (Silme) - O(log n) 🤔

Bu en karmaşık işlem! 3 durum var:

```csharp
public BSTNode Delete(BSTNode root, int val)
{
    if (root == null) return null; // Değer bulunamadı
    
    if (val < root.Val)
        root.Left = Delete(root.Left, val);
    else if (val > root.Val)
        root.Right = Delete(root.Right, val);
    else // val == root.Val, silinecek node bulundu!
    {
        // Case 1: Leaf node (çocuk yok)
        if (root.Left == null && root.Right == null)
            return null;
        
        // Case 2: Tek çocuk var
        if (root.Left == null)
            return root.Right;
        if (root.Right == null)
            return root.Left;
        
        // Case 3: İki çocuk var - en karmaşık durum!
        // Sağ alt ağaçtaki en küçük değeri bul (inorder successor)
        int minVal = FindMin(root.Right);
        root.Val = minVal; // Current node'un değerini değiştir
        root.Right = Delete(root.Right, minVal); // Successor'ı sil
    }
    
    return root;
}
```

### Silme İşleminin Görsel Açıklaması:
```
Silme Case 3 örneği:
       50
      /  \
    30    70    ← 50'yi silmek istiyoruz
   /  \   /  \
  20  40 60  80

Adımlar:
1. 50'nin sağ alt ağacındaki en küçük: 60
2. 50'yi 60 ile değiştir
3. 60'ı orijinal yerinden sil

Sonuç:
       60
      /  \
    30    70
   /  \    \
  20  40   80
```

## BST Traversal ve Sıralama

### Inorder Traversal = Sıralı Liste!
```csharp
// Inorder: Left → Root → Right
public void InorderTraversal(BSTNode root, List<int> result)
{
    if (root == null) return;
    
    InorderTraversal(root.Left, result);   // Sol
    result.Add(root.Val);                  // Root
    InorderTraversal(root.Right, result);  // Sağ
}

// BST'deki tüm elemanları sıralı şekilde al
public List<int> GetSortedElements()
{
    List<int> result = new List<int>();
    InorderTraversal(Root, result);
    return result; // Otomatik olarak sıralı!
}
```

### BST'den Range Query
```csharp
// Belirli aralıktaki değerleri bul
public List<int> RangeQuery(BSTNode root, int min, int max)
{
    List<int> result = new List<int>();
    RangeQueryHelper(root, min, max, result);
    return result;
}

private void RangeQueryHelper(BSTNode root, int min, int max, List<int> result)
{
    if (root == null) return;
    
    // Current value aralıkta mı?
    if (root.Val >= min && root.Val <= max)
        result.Add(root.Val);
    
    // Sol alt ağaca git (eğer mantıklıysa)
    if (root.Val > min)
        RangeQueryHelper(root.Left, min, max, result);
    
    // Sağ alt ağaca git (eğer mantıklıysa)
    if (root.Val < max)
        RangeQueryHelper(root.Right, min, max, result);
}
```

## BST Validation (Doğrulama)

Bir tree'nin gerçekten BST olup olmadığını kontrol etmek:

```csharp
// BST property'sini kontrol et
public bool IsValidBST(BSTNode root)
{
    return IsValidBSTHelper(root, int.MinValue, int.MaxValue);
}

private bool IsValidBSTHelper(BSTNode root, int min, int max)
{
    if (root == null) return true;
    
    // Current node sınırlar içinde mi?
    if (root.Val <= min || root.Val >= max)
        return false;
    
    // Sol alt ağaç: üst sınır current value
    // Sağ alt ağaç: alt sınır current value
    return IsValidBSTHelper(root.Left, min, root.Val) &&
           IsValidBSTHelper(root.Right, root.Val, max);
}
```

## BST'nin Gerçek Hayat Uygulamaları

### 1. Database Index
```csharp
// Database'deki kayıtları hızlı arama için
public class DatabaseIndex
{
    private BSTNode root;
    
    public void AddRecord(int id)
    {
        root = Insert(root, id);
    }
    
    public bool RecordExists(int id)
    {
        return Search(root, id); // O(log n) arama!
    }
}
```

### 2. Auto-complete System
```csharp
// String BST for auto-complete
public class AutoComplete
{
    public class StringBSTNode
    {
        public string Word { get; set; }
        public StringBSTNode Left { get; set; }
        public StringBSTNode Right { get; set; }
        
        public StringBSTNode(string word)
        {
            Word = word;
        }
    }
    
    private StringBSTNode root;
    
    public void AddWord(string word)
    {
        root = InsertString(root, word);
    }
    
    private StringBSTNode InsertString(StringBSTNode root, string word)
    {
        if (root == null)
            return new StringBSTNode(word);
        
        if (string.Compare(word, root.Word) < 0)
            root.Left = InsertString(root.Left, word);
        else if (string.Compare(word, root.Word) > 0)
            root.Right = InsertString(root.Right, word);
        
        return root;
    }
}
```

## BST Performance Analizi

### ⚡ Best Case (Balanced Tree):
- **Search:** O(log n)
- **Insert:** O(log n)
- **Delete:** O(log n)
- **Min/Max:** O(log n)

### 🐌 Worst Case (Degenerate Tree):
```
Degenerate BST (LinkedList gibi):
1
 \
  2
   \
    3
     \
      4

Tüm operasyonlar O(n) olur!
```

### 🎯 BST'yi Balanced Tutma:
Bu durumda **AVL Tree** veya **Red-Black Tree** kullanılır (self-balancing).

## BST vs Diğer Veri Yapıları

| Özellik | Array (Sorted) | HashMap | BST |
|---------|---------------|---------|-----|
| **Search** | O(log n) | O(1) avg | O(log n) |
| **Insert** | O(n) | O(1) avg | O(log n) |
| **Sorted order** | Manual | ❌ | Otomatik ✅ |
| **Range query** | O(log n + k) | O(n) | O(log n + k) |
| **Memory** | Compact | Extra | Extra |

## BST Ne Zaman Kullanılır?

### ✅ BST Kullan Eğer:
- **Sorted order** önemliyse
- **Range queries** yapacaksan
- **Minimum/Maximum** sık bulacaksan
- **Dynamic dataset** ve sıralama gerekiyorsa
- **Predecessor/Successor** bulma gerekiyorsa

### ❌ BST Kullanma Eğer:
- **Only key lookup** gerekiyorsa (HashMap kullan)
- **Fixed dataset** (Sorted array kullan)
- **Memory critical** (Array daha efficient)
- **Worst case guarantee** gerekiyorsa (Balanced BST kullan)

## Advanced BST Concepts

### 1. Kth Smallest Element
```csharp
// BST'deki k'ıncı en küçük elemanı bul
public int KthSmallest(BSTNode root, int k)
{
    int count = 0;
    return KthSmallestHelper(root, k, ref count);
}

private int KthSmallestHelper(BSTNode root, int k, ref int count)
{
    if (root == null) return -1;
    
    // Sol alt ağaçta ara
    int leftResult = KthSmallestHelper(root.Left, k, ref count);
    if (leftResult != -1) return leftResult;
    
    // Current node
    count++;
    if (count == k) return root.Val;
    
    // Sağ alt ağaçta ara
    return KthSmallestHelper(root.Right, k, ref count);
}
```

BST, sorting ve searching problemlerinin elegant çözümü! Next: Tree Traversal teknikleri 🌲