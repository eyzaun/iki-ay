# BFS (Breadth-First Search) ve Graph YapÄ±larÄ±

## BFS Nedir? DFS'den FarkÄ± Ne?

BFS, **seviye seviye (level-by-level)** gezinme tekniÄŸidir. TÄ±pkÄ± **taÅŸ havuza atÄ±ldÄ±ÄŸÄ±nda** oluÅŸan dalgalar gibi - merkez noktadan baÅŸlayÄ±p dÄ±ÅŸa doÄŸru geniÅŸler.

### GerÃ§ek Hayattan Benzetme: SalgÄ±n YayÄ±lÄ±mÄ±
DÃ¼ÅŸÃ¼n ki bir ÅŸehirde salgÄ±n baÅŸladÄ±:
- **BFS:** SalgÄ±n Ã¶nce **komÅŸu mahallelere**, sonra **daha uzak bÃ¶lgelere** yayÄ±lÄ±r
- **DFS:** SalgÄ±n **bir yol takip ederek** ÅŸehrin en ucuna gider, sonra geri dÃ¶nÃ¼p baÅŸka yollarÄ± dener

### GÃ¶rsel KarÅŸÄ±laÅŸtÄ±rma:
```
Tree:
       1
      / \
     2   3
    / \ / \
   4 5 6  7

DFS (Preorder): 1 â†’ 2 â†’ 4 â†’ 5 â†’ 3 â†’ 6 â†’ 7  (Derinlemesine)
BFS (Level):    1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7  (Seviye seviye)
```

## BFS'in Kalbi: Queue KullanÄ±mÄ±

BFS **her zaman Queue** kullanÄ±r! DFS Stack kullanÄ±rken, BFS Queue kullanÄ±r.

```csharp
// BFS - Level Order Traversal
public List<int> BFS(TreeNode root)
{
    List<int> result = new List<int>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root);
    
    while (queue.Count > 0)
    {
        TreeNode current = queue.Dequeue(); // FIFO - Ä°lk giren ilk Ã§Ä±kar
        result.Add(current.Val);
        
        // Ã‡ocuklarÄ± kuyruÄŸa ekle (sol Ã¶nce, saÄŸ sonra)
        if (current.Left != null)
            queue.Enqueue(current.Left);
        if (current.Right != null)
            queue.Enqueue(current.Right);
    }
    
    return result;
}
```

## Level-Order Traversal Variations

### 1. Seviyeli BFS (Her Seviyeyi AyrÄ± Listede)
```csharp
public List<List<int>> LevelOrder(TreeNode root)
{
    List<List<int>> result = new List<List<int>>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root);
    
    while (queue.Count > 0)
    {
        int levelSize = queue.Count; // Mevcut seviyedeki node sayÄ±sÄ±
        List<int> currentLevel = new List<int>();
        
        // Bu seviyedeki tÃ¼m node'larÄ± iÅŸle
        for (int i = 0; i < levelSize; i++)
        {
            TreeNode current = queue.Dequeue();
            currentLevel.Add(current.Val);
            
            // Sonraki seviyenin node'larÄ±nÄ± ekle
            if (current.Left != null)
                queue.Enqueue(current.Left);
            if (current.Right != null)
                queue.Enqueue(current.Right);
        }
        
        result.Add(currentLevel);
    }
    
    return result;
}

// Ã–rnek Ã§Ä±ktÄ±: [[1], [2,3], [4,5,6,7]]
```

### 2. Zigzag Level Order
```csharp
public List<List<int>> ZigzagLevelOrder(TreeNode root)
{
    List<List<int>> result = new List<List<int>>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root);
    bool leftToRight = true;
    
    while (queue.Count > 0)
    {
        int levelSize = queue.Count;
        List<int> currentLevel = new List<int>();
        
        for (int i = 0; i < levelSize; i++)
        {
            TreeNode current = queue.Dequeue();
            
            if (leftToRight)
                currentLevel.Add(current.Val);
            else
                currentLevel.Insert(0, current.Val); // BaÅŸa ekle (reverse)
            
            if (current.Left != null)
                queue.Enqueue(current.Left);
            if (current.Right != null)
                queue.Enqueue(current.Right);
        }
        
        result.Add(currentLevel);
        leftToRight = !leftToRight; // YÃ¶n deÄŸiÅŸtir
    }
    
    return result;
}

// Ã–rnek Ã§Ä±ktÄ±: [[1], [3,2], [4,5,6,7]]
```

### 3. Right Side View
```csharp
// Tree'nin saÄŸdan gÃ¶rÃ¼nÃ¼mÃ¼
public List<int> RightSideView(TreeNode root)
{
    List<int> result = new List<int>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root);
    
    while (queue.Count > 0)
    {
        int levelSize = queue.Count;
        
        for (int i = 0; i < levelSize; i++)
        {
            TreeNode current = queue.Dequeue();
            
            // Son node (saÄŸdaki) gÃ¶rÃ¼nÃ¼r
            if (i == levelSize - 1)
                result.Add(current.Val);
            
            if (current.Left != null)
                queue.Enqueue(current.Left);
            if (current.Right != null)
                queue.Enqueue(current.Right);
        }
    }
    
    return result;
}
```

## Graph Veri YapÄ±sÄ±

Graph, **node'larÄ±n (vertex) edge'lerle baÄŸlandÄ±ÄŸÄ±** yapÄ±dÄ±r. Tree'nin genelleÅŸtirilmiÅŸ hali!

### Graph vs Tree:
- **Tree:** Cycle yok, connected, n-1 edge
- **Graph:** Cycle olabilir, disconnected olabilir, any number of edges

### Graph TÃ¼rleri:
1. **Directed/Undirected:** Ok yÃ¶nlÃ¼ mÃ¼?
2. **Weighted/Unweighted:** Kenar aÄŸÄ±rlÄ±klarÄ± var mÄ±?
3. **Connected/Disconnected:** TÃ¼m node'lar eriÅŸilebilir mi?

## Graph Representation (Temsil YÃ¶ntemleri)

### 1. Adjacency List (En YaygÄ±n)
```csharp
// Adjacency List ile Graph
public class Graph
{
    private Dictionary<int, List<int>> adjList;
    
    public Graph()
    {
        adjList = new Dictionary<int, List<int>>();
    }
    
    public void AddVertex(int vertex)
    {
        if (!adjList.ContainsKey(vertex))
            adjList[vertex] = new List<int>();
    }
    
    public void AddEdge(int source, int destination)
    {
        AddVertex(source);
        AddVertex(destination);
        
        adjList[source].Add(destination);
        // Undirected graph iÃ§in:
        // adjList[destination].Add(source);
    }
    
    public List<int> GetNeighbors(int vertex)
    {
        return adjList.ContainsKey(vertex) ? adjList[vertex] : new List<int>();
    }
}
```

### 2. Adjacency Matrix
```csharp
// Matrix ile Graph
public class GraphMatrix
{
    private int[,] matrix;
    private int vertices;
    
    public GraphMatrix(int vertices)
    {
        this.vertices = vertices;
        matrix = new int[vertices, vertices];
    }
    
    public void AddEdge(int source, int destination, int weight = 1)
    {
        matrix[source, destination] = weight;
        // Undirected iÃ§in:
        // matrix[destination, source] = weight;
    }
    
    public bool HasEdge(int source, int destination)
    {
        return matrix[source, destination] != 0;
    }
}
```

## Graph'ta BFS Implementation

```csharp
// Graph'ta BFS - En kÄ±sa yol bulur (unweighted)
public List<int> BFSGraph(Graph graph, int startVertex)
{
    List<int> result = new List<int>();
    HashSet<int> visited = new HashSet<int>();
    Queue<int> queue = new Queue<int>();
    
    queue.Enqueue(startVertex);
    visited.Add(startVertex);
    
    while (queue.Count > 0)
    {
        int current = queue.Dequeue();
        result.Add(current);
        
        // KomÅŸularÄ± kontrol et
        foreach (int neighbor in graph.GetNeighbors(current))
        {
            if (!visited.Contains(neighbor))
            {
                visited.Add(neighbor);
                queue.Enqueue(neighbor);
            }
        }
    }
    
    return result;
}
```

## Graph'ta DFS Implementation

```csharp
// Graph'ta DFS - Recursive
public List<int> DFSGraph(Graph graph, int startVertex, HashSet<int> visited = null)
{
    if (visited == null)
        visited = new HashSet<int>();
    
    List<int> result = new List<int>();
    
    visited.Add(startVertex);
    result.Add(startVertex);
    
    foreach (int neighbor in graph.GetNeighbors(startVertex))
    {
        if (!visited.Contains(neighbor))
        {
            result.AddRange(DFSGraph(graph, neighbor, visited));
        }
    }
    
    return result;
}

// DFS - Iterative (Stack kullanarak)
public List<int> DFSIterative(Graph graph, int startVertex)
{
    List<int> result = new List<int>();
    HashSet<int> visited = new HashSet<int>();
    Stack<int> stack = new Stack<int>();
    
    stack.Push(startVertex);
    
    while (stack.Count > 0)
    {
        int current = stack.Pop();
        
        if (!visited.Contains(current))
        {
            visited.Add(current);
            result.Add(current);
            
            // KomÅŸularÄ± ters sÄ±rada ekle (dÃ¼zen iÃ§in)
            var neighbors = graph.GetNeighbors(current);
            for (int i = neighbors.Count - 1; i >= 0; i--)
            {
                if (!visited.Contains(neighbors[i]))
                    stack.Push(neighbors[i]);
            }
        }
    }
    
    return result;
}
```

## BFS'in GerÃ§ek Hayat UygulamalarÄ±

### 1. Shortest Path (En KÄ±sa Yol)
```csharp
// Unweighted graph'ta en kÄ±sa yol
public int ShortestPath(Graph graph, int start, int target)
{
    if (start == target) return 0;
    
    Queue<int> queue = new Queue<int>();
    HashSet<int> visited = new HashSet<int>();
    Dictionary<int, int> distance = new Dictionary<int, int>();
    
    queue.Enqueue(start);
    visited.Add(start);
    distance[start] = 0;
    
    while (queue.Count > 0)
    {
        int current = queue.Dequeue();
        
        foreach (int neighbor in graph.GetNeighbors(current))
        {
            if (!visited.Contains(neighbor))
            {
                visited.Add(neighbor);
                distance[neighbor] = distance[current] + 1;
                queue.Enqueue(neighbor);
                
                if (neighbor == target)
                    return distance[neighbor];
            }
        }
    }
    
    return -1; // Path bulunamadÄ±
}
```

### 2. Connected Components
```csharp
// Graph'taki baÄŸlÄ± bileÅŸen sayÄ±sÄ±
public int CountConnectedComponents(Graph graph, List<int> allVertices)
{
    HashSet<int> visited = new HashSet<int>();
    int components = 0;
    
    foreach (int vertex in allVertices)
    {
        if (!visited.Contains(vertex))
        {
            BFSComponent(graph, vertex, visited);
            components++;
        }
    }
    
    return components;
}

private void BFSComponent(Graph graph, int start, HashSet<int> visited)
{
    Queue<int> queue = new Queue<int>();
    queue.Enqueue(start);
    visited.Add(start);
    
    while (queue.Count > 0)
    {
        int current = queue.Dequeue();
        
        foreach (int neighbor in graph.GetNeighbors(current))
        {
            if (!visited.Contains(neighbor))
            {
                visited.Add(neighbor);
                queue.Enqueue(neighbor);
            }
        }
    }
}
```

### 3. Level Distance (Belirli Mesafedeki Node'lar)
```csharp
// Belirli mesafedeki tÃ¼m node'larÄ± bul
public List<int> NodesAtDistance(Graph graph, int start, int targetDistance)
{
    List<int> result = new List<int>();
    Queue<int> queue = new Queue<int>();
    HashSet<int> visited = new HashSet<int>();
    Dictionary<int, int> distance = new Dictionary<int, int>();
    
    queue.Enqueue(start);
    visited.Add(start);
    distance[start] = 0;
    
    while (queue.Count > 0)
    {
        int current = queue.Dequeue();
        
        if (distance[current] == targetDistance)
        {
            result.Add(current);
        }
        
        if (distance[current] < targetDistance)
        {
            foreach (int neighbor in graph.GetNeighbors(current))
            {
                if (!visited.Contains(neighbor))
                {
                    visited.Add(neighbor);
                    distance[neighbor] = distance[current] + 1;
                    queue.Enqueue(neighbor);
                }
            }
        }
    }
    
    return result;
}
```

## BFS vs DFS - Ne Zaman Hangisi?

| Ã–zellik | BFS | DFS |
|---------|-----|-----|
| **Veri YapÄ±sÄ±** | Queue | Stack/Recursion |
| **Memory** | O(branching factor) | O(depth) |
| **Shortest Path** | âœ… Garanti | âŒ Garanti yok |
| **Space Complexity** | Genelde daha fazla | Genelde daha az |
| **Use Cases** | Level-order, shortest path | Path finding, topological sort |

## BFS vs DFS KullanÄ±m AlanlarÄ±

### âœ… BFS Kullan EÄŸer:
- **Shortest path** (unweighted) buluyorsan
- **Level-order** iÅŸlem gerekiyorsa
- **Minimum steps** problemi Ã§Ã¶zÃ¼yorsan
- **Connected components** sayÄ±yorsan

### âœ… DFS Kullan EÄŸer:
- **Path existence** kontrol ediyorsan
- **Cycle detection** yapÄ±yorsan
- **Topological sorting** gerekiyorsa
- **Memory** sÄ±nÄ±rlÄ± ise

## Complexity Analizi

### Time Complexity: **O(V + E)**
- V = vertex (node) sayÄ±sÄ±
- E = edge sayÄ±sÄ±
- Her vertex ve edge bir kez ziyaret edilir

### Space Complexity:
- **BFS:** O(V) - Queue iÃ§in
- **DFS:** O(V) - Stack/Recursion iÃ§in

Next: Sorting Algorithms (MergeSort, QuickSort)! ğŸ”„