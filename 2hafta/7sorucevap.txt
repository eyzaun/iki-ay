# Hafta 2 DSA - Soru & Cevap

## ğŸŒ³ Binary Tree

**S1: Binary Tree nedir ve normal tree'den farkÄ± nedir?**
**C:** Binary Tree, her node'un **en fazla 2 Ã§ocuÄŸu** olan tree'dir (sol ve saÄŸ). Normal tree'de node'un istediÄŸi kadar Ã§ocuÄŸu olabilir. Bu kÄ±sÄ±tlama, algoritmalarÄ± daha basit ve efficient yapar.

**S2: Complete Binary Tree ile Full Binary Tree arasÄ±ndaki fark nedir?**
**C:** 
- **Complete:** Son seviye hariÃ§ tÃ¼m seviyeler dolu, son seviye soldan dolu
- **Full:** Her node'un 0 veya 2 Ã§ocuÄŸu var (1 Ã§ocuk yok)

**S3: Binary Tree'nin height'ini hesaplayan algoritmanÄ±n Big-O karmaÅŸÄ±klÄ±ÄŸÄ± nedir?**
**C:** **O(n)** - Ã‡Ã¼nkÃ¼ height'i bulmak iÃ§in tÃ¼m node'larÄ± ziyaret etmek gerekir (worst case'de tree degenerate olabilir).

**S4: Binary Tree'de leaf node sayÄ±sÄ±nÄ± bulan kodun logic'i nasÄ±l Ã§alÄ±ÅŸÄ±r?**
**C:** Recursive: EÄŸer node null ise 0 dÃ¶ndÃ¼r. EÄŸer node leaf ise (sol ve saÄŸ Ã§ocuk null) 1 dÃ¶ndÃ¼r. DeÄŸilse sol ve saÄŸ alt aÄŸaÃ§larÄ±n leaf sayÄ±sÄ±nÄ± topla.

**S5: Binary Tree ne zaman LinkedList'ten daha avantajlÄ±?**
**C:** **Hierarchical data** saklarken, **parent-child iliÅŸkileri** Ã¶nemli olduÄŸunda, ve **recursive algorithms** kullanÄ±rken daha avantajlÄ±.

---

## ğŸ” Binary Search Tree (BST)

**S1: BST'nin temel property'si nedir ve neden bu Ã¶zellik Ã¶nemli?**
**C:** **Sol Ã§ocuk < Parent < SaÄŸ Ã§ocuk** kuralÄ±. Bu Ã¶zellik sayesinde **O(log n)** arama, ekleme, silme iÅŸlemleri yapabilir ve **inorder traversal** ile sÄ±ralÄ± liste elde ederiz.

**S2: BST'de search iÅŸlemi neden O(log n) sÃ¼rer?**
**C:** Her adÄ±mda arama alanÄ±nÄ± yarÄ±ya bÃ¶ldÃ¼ÄŸÃ¼mÃ¼z iÃ§in. Target'Ä± current node ile karÅŸÄ±laÅŸtÄ±rÄ±p ya sol ya saÄŸ alt aÄŸaca gideriz, bÃ¶ylece logaritmik zaman elde ederiz.

**S3: BST'den sorted bir liste elde etmek iÃ§in hangi traversal kullanÄ±lÄ±r?**
**C:** **Inorder traversal** (Left â†’ Root â†’ Right). BST property'si sayesinde bu sÄ±ralama otomatik olarak sorted order verir.

**S4: BST'de node silme iÅŸleminin 3 case'i nedir?**
**C:** 
1. **Leaf node:** Direkt sil
2. **Tek Ã§ocuk:** Ã‡ocuÄŸu parent'a baÄŸla
3. **Ä°ki Ã§ocuk:** Inorder successor (saÄŸ alt aÄŸaÃ§taki en kÃ¼Ã§Ã¼k) ile deÄŸiÅŸtir

**S5: Degenerate BST nedir ve neden kÃ¶tÃ¼dÃ¼r?**
**C:** LinkedList gibi tek taraflÄ± uzamÄ±ÅŸ BST. TÃ¼m operasyonlar O(n) olur Ã§Ã¼nkÃ¼ tree'nin avantajÄ± kalmaz. Bu durumda balanced tree (AVL, Red-Black) kullanÄ±lÄ±r.

**S6: BST'de range query [min, max] nasÄ±l yapÄ±lÄ±r?**
**C:** Recursive: Current node range iÃ§indeyse result'a ekle. Node > min ise sol alt aÄŸacÄ±, node < max ise saÄŸ alt aÄŸacÄ± ziyaret et. BST property sayesinde gereksiz branch'leri atlarÄ±z.

---

## ğŸŒŠ Tree Traversal (DFS)

**S7: DFS'in 3 tÃ¼rÃ¼ nedir ve hangi sÄ±rayla node'larÄ± ziyaret ederler?**
**C:** 
- **Preorder:** Root â†’ Left â†’ Right
- **Inorder:** Left â†’ Root â†’ Right  
- **Postorder:** Left â†’ Right â†’ Root

**S8: Preorder traversal ne zaman kullanÄ±lÄ±r?**
**C:** **Tree copying**, **serialization** (tree'yi string'e Ã§evirme), **directory structure** yazdÄ±rma gibi **top-down** iÅŸlemler iÃ§in.

**S9: Postorder traversal'Ä±n tipik kullanÄ±m alanlarÄ± nelerdir?**
**C:** **Tree deletion** (alt aÄŸaÃ§larÄ± Ã¶nce sil), **directory size calculation**, **expression evaluation** gibi **bottom-up** iÅŸlemler iÃ§in.

**S10: Bu kod hangi traversal tÃ¼rÃ¼dÃ¼r?**
```csharp
void Traverse(TreeNode root) {
    if (root == null) return;
    Console.WriteLine(root.val);
    Traverse(root.left);
    Traverse(root.right);
}
```
**C:** **Preorder** traversal (Root Ã¶nce, sonra Left, sonra Right).

**S11: DFS'in space complexity'si nedir ve neden?**
**C:** **O(h)** - h = tree height. Recursive call stack'i tree derinliÄŸi kadar yer kaplar. Balanced tree'de O(log n), worst case'de O(n).

---

## ğŸš¶â€â™‚ï¸ BFS (Breadth-First Search)

**S12: BFS hangi veri yapÄ±sÄ±nÄ± kullanÄ±r ve neden?**
**C:** **Queue** kullanÄ±r. FIFO (First In, First Out) prensibi sayesinde **level-order** (seviye seviye) gezinme saÄŸlar.

**S13: BFS ile DFS arasÄ±ndaki temel fark nedir?**
**C:** 
- **BFS:** Seviye seviye (geniÅŸlemesine), Queue kullanÄ±r
- **DFS:** Derinlemesine, Stack/Recursion kullanÄ±r

**S14: Tree'nin Right Side View'Ä±nÄ± bulmak iÃ§in BFS nasÄ±l kullanÄ±lÄ±r?**
**C:** Her level'da **en saÄŸdaki node**'u al. BFS ile level-by-level ilerleyip her seviyenin son elemanÄ±nÄ± result'a ekle.

**S15: BFS'in graph'ta temel kullanÄ±m alanlarÄ± nelerdir?**
**C:** **Shortest path** (unweighted), **level-order processing**, **connected components** bulma, **minimum steps** problemleri.

**S16: Graph'ta BFS ile DFS'in space complexity farkÄ± nedir?**
**C:** 
- **BFS:** O(width) - en geniÅŸ seviye kadar queue
- **DFS:** O(depth) - en derin seviye kadar stack

---

## ğŸ“Š Graph YapÄ±larÄ±

**S17: Adjacency List ile Adjacency Matrix arasÄ±ndaki fark nedir?**
**C:** 
- **Adjacency List:** Her vertex iÃ§in komÅŸularÄ±n listesi. Space: O(V+E), Edge check: O(degree)
- **Adjacency Matrix:** VÃ—V matrix. Space: O(VÂ²), Edge check: O(1)

**S18: Sparse graph'ta hangisi daha efficient?**
**C:** **Adjacency List**. Ã‡Ã¼nkÃ¼ sadece var olan edge'ler iÃ§in yer kullanÄ±r (O(V+E)), matrix ise tÃ¼m possible edge'ler iÃ§in yer ayÄ±rÄ±r (O(VÂ²)).

**S19: Graph'ta cycle detection iÃ§in DFS nasÄ±l kullanÄ±lÄ±r?**
**C:** DFS sÄ±rasÄ±nda **3 renk** kullan: White (unvisited), Gray (processing), Black (finished). Gray node'a tekrar ulaÅŸÄ±rsan cycle var demektir.

**S20: Connected components sayÄ±sÄ±nÄ± BFS ile nasÄ±l bulursun?**
**C:** TÃ¼m unvisited node'lar iÃ§in BFS baÅŸlat. Her BFS Ã§aÄŸrÄ±sÄ± bir component'i kapsar, toplam Ã§aÄŸrÄ± sayÄ±sÄ± = component sayÄ±sÄ±.

---

## ğŸ”„ Sorting Algorithms

**S21: Divide & Conquer stratejisi nedir?**
**C:** 
1. **Divide:** Problemi kÃ¼Ã§Ã¼k parÃ§alara bÃ¶l
2. **Conquer:** KÃ¼Ã§Ã¼k parÃ§alarÄ± Ã§Ã¶z  
3. **Combine:** SonuÃ§larÄ± birleÅŸtir

**S22: MergeSort'un guaranteed O(n log n) olmasÄ±nÄ±n nedeni nedir?**
**C:** Her zaman array'i **tam yarÄ±ya bÃ¶ler** (log n seviye) ve her seviyede **linear merge** yapar (n iÅŸlem). Input'tan baÄŸÄ±msÄ±z olarak hep aynÄ± performance.

**S23: QuickSort'un worst case ne zaman O(nÂ²) olur?**
**C:** **Pivot selection kÃ¶tÃ¼** olduÄŸunda. Ã–rneÄŸin zaten sorted array'de hep en kÃ¼Ã§Ã¼k/bÃ¼yÃ¼k elemanÄ± pivot seÃ§ersen, partition balanced olmaz.

**S24: Stable sorting algorithm nedir? MergeSort stable mÄ±, QuickSort stable mÄ±?**
**C:** **Stable:** EÅŸit elemanlarÄ±n relatif sÄ±rasÄ± korunur. **MergeSort stable**, **QuickSort stable deÄŸil**.

**S25: Hangi durumda QuickSort, MergeSort'tan daha iyi?**
**C:** **Memory sÄ±nÄ±rlÄ±** durumlarda. QuickSort in-place (O(1) extra space), MergeSort O(n) extra space gerektirir.

**S26: Hibrit sorting (IntroSort) neden kullanÄ±lÄ±r?**
**C:** **Best of both worlds**: KÃ¼Ã§Ã¼k arrays iÃ§in InsertionSort, normal durumda QuickSort, worst case'de HeapSort kullanarak her duruma optimize eder.

---

## ğŸ” Binary Search Advanced

**S27: Lower bound ve Upper bound arasÄ±ndaki fark nedir?**
**C:** 
- **Lower bound:** Target'Ä±n **ilk gÃ¶rÃ¼ldÃ¼ÄŸÃ¼** index
- **Upper bound:** Target'tan **bÃ¼yÃ¼k ilk elemanÄ±n** index'i

**S28: Rotated sorted array'de arama nasÄ±l yapÄ±lÄ±r?**
**C:** Binary search'te **hangi yarÄ±nÄ±n sorted** olduÄŸunu kontrol et. Target sorted yarÄ±da mÄ± deÄŸil mi'ye gÃ¶re arama yÃ¶nÃ¼nÃ¼ belirle.

**S29: "Search in answer space" tekniÄŸi nedir?**
**C:** Direct arama yerine **possible answer'lar Ã¼zerinde binary search**. Ã–rnek: "Minimum capacity" bulma - capacity deÄŸerleri Ã¼zerinde binary search yap.

**S30: Binary search'te mid hesaplarken neden `left + (right-left)/2` kullanÄ±rÄ±z?**
**C:** `(left+right)/2` **integer overflow** yapabilir. `left + (right-left)/2` formÃ¼lÃ¼ overflow'u Ã¶nler.

**S31: Peak element bulma algoritmasÄ± nasÄ±l Ã§alÄ±ÅŸÄ±r?**
**C:** Binary search: Mid element'in saÄŸ komÅŸusu bÃ¼yÃ¼kse peak saÄŸ tarafta, deÄŸilse sol tarafta. O(log n)'de peak bulur.

---

## ğŸ§  Genel Algorithm Design

**S32: Recursive algoritmanÄ±n 3 temel bileÅŸeni nedir?**
**C:** 
1. **Base case:** Recursion'u durduran koÅŸul
2. **Recursive case:** Problemi kÃ¼Ã§Ã¼lten kÄ±sÄ±m
3. **Progress:** Her Ã§aÄŸrÄ±da problem kÃ¼Ã§Ã¼lmeli

**S33: Tree problemlerinde hangi traversal tÃ¼rÃ¼nÃ¼ ne zaman kullanÄ±rsÄ±n?**
**C:** 
- **Preorder:** Copying, serialization, top-down processing
- **Inorder:** BST'de sorted order, validation
- **Postorder:** Deletion, size calculation, bottom-up
- **Level-order (BFS):** Level-wise operations, shortest path

**S34: Stack overflow'u Ã¶nlemek iÃ§in recursive algoritmalarÄ± nasÄ±l optimize edersin?**
**C:** 
1. **Iterative version** yaz (Stack/Queue kullan)
2. **Tail recursion** optimization
3. **Memoization** ile duplicate calls'larÄ± Ã¶nle

**S35: Greedy vs Divide & Conquer vs Dynamic Programming - temel farklar?**
**C:** 
- **Greedy:** Her adÄ±mda local optimal seÃ§im (her zaman optimal deÄŸil)
- **Divide & Conquer:** Problemi bÃ¶l, Ã§Ã¶z, birleÅŸtir
- **DP:** Overlapping subproblems'Ä± memoize et

---

## ğŸ¯ Problem Solving Patterns

**S36: Tree'de path sum problemi nasÄ±l Ã§Ã¶zÃ¼lÃ¼r?**
**C:** DFS ile current sum'Ä± track et. Leaf'e ulaÅŸtÄ±ÄŸÄ±nda target ile karÅŸÄ±laÅŸtÄ±r. Backtracking ile tÃ¼m path'leri kontrol et.

**S37: Graph'ta shortest path bulmanÄ±n farklÄ± yollarÄ± nelerdir?**
**C:** 
- **Unweighted:** BFS (O(V+E))
- **Weighted positive:** Dijkstra (O(V log V + E))
- **Weighted with negative:** Bellman-Ford (O(VE))
- **All pairs:** Floyd-Warshall (O(VÂ³))

**S38: Binary search'in uygulanabilirlik koÅŸulu nedir?**
**C:** **Monotonic property** - arama kriterine gÃ¶re "evet/hayÄ±r" cevabÄ±nÄ±n tek yÃ¶nlÃ¼ deÄŸiÅŸmesi. Sorted olmasÄ± ÅŸart deÄŸil, monotonic olmasÄ± yeter.

**S39: Tree'de LCA (Lowest Common Ancestor) nasÄ±l bulunur?**
**C:** **BST'de:** Value'larÄ± karÅŸÄ±laÅŸtÄ±r. **Normal tree'de:** DFS ile path'leri bul ya da parent pointer'larÄ± kullan.

**S40: In-place algoritma nedir ve avantajÄ± nedir?**
**C:** **Extra space kullanmayan** (O(1) space) algoritma. Memory efficient, Ã¶zellikle bÃ¼yÃ¼k data setlerinde Ã¶nemli. Ã–rnek: QuickSort, HeapSort.

---

## âš¡ Performance & Optimization

**S41: Cache-friendly algorithm nedir?**
**C:** **Memory locality** iyi olan algoritma. Sequential memory access yapan (Array traversal) algoritmalarÄ±, random access yapanlardan (LinkedList, Tree) daha cache-friendly.

**S42: Recursive vs Iterative - performance farklarÄ± nelerdir?**
**C:** 
- **Recursive:** Clean code, ama function call overhead ve stack space
- **Iterative:** Daha az overhead, daha az memory, ama kod karmaÅŸÄ±k olabilir

**S43: Hangi sorting algorithm'Ä± ne zaman kullanÄ±rsÄ±n?**
**C:** 
- **Small arrays (â‰¤16):** InsertionSort
- **General purpose:** QuickSort veya IntroSort
- **Stability gerekli:** MergeSort
- **Memory critical:** HeapSort
- **Partially sorted:** TimSort

**S44: Tree operations'Ä±n amortized complexity'si ne demek?**
**C:** **Ortalama performans** - worst case nadir olduÄŸunda overall performance iyi. Ã–rnek: Dynamic array resize O(n) ama amortized O(1).

**S45: Graph representation seÃ§imi nasÄ±l yapÄ±lÄ±r?**
**C:** 
- **Dense graph (Ã§ok edge):** Adjacency Matrix
- **Sparse graph (az edge):** Adjacency List  
- **Frequent edge queries:** Matrix
- **Memory efficient:** List

Bu sorularla Hafta 2'nin tÃ¼m Ã¶nemli kavramlarÄ±nÄ± kapsamlÄ± ÅŸekilde pekiÅŸtirmiÅŸ oldun! ArtÄ±k **advanced algoritma problemlerine** geÃ§meye hazÄ±rsÄ±n! ğŸš€