# Binary Tree - AÄŸaÃ§ Veri YapÄ±sÄ±nÄ±n Temeli

## Binary Tree Nedir? Neden Bu Kadar Ã–nemli?

Binary Tree'yi **aile soybaÄŸacÄ±** gibi dÃ¼ÅŸÃ¼n. Her kiÅŸinin en fazla **2 Ã§ocuÄŸu** olabilir (sol ve saÄŸ). Bu basit kural, inanÄ±lmaz gÃ¼Ã§lÃ¼ veri yapÄ±larÄ± yaratmamÄ±zÄ± saÄŸlar.

### GerÃ§ek Hayattan Benzetme: Karar AÄŸacÄ±
DÃ¼ÅŸÃ¼n ki kahvaltÄ±da ne yiyeceÄŸine karar veriyorsun:

```
        AcÄ±ktÄ±n mÄ±?
       /            \
    Evet             HayÄ±r
   /    \              |
TatlÄ±   Tuzlu      Bir ÅŸey iÃ§me
 |       |
Krep   Omlet
```

Ä°ÅŸte bu bir Binary Tree! Her **dÃ¼ÄŸÃ¼mde (node)** bir karar var, en fazla **2 seÃ§enek** var.

## Binary Tree'nin Anatomisi

### Temel Kavramlar:
- **Root (KÃ¶k):** En Ã¼stteki node - baÅŸlangÄ±Ã§ noktasÄ±
- **Parent (Ebeveyn):** Ãœstteki node
- **Child (Ã‡ocuk):** Alttaki node'lar (sol/saÄŸ)
- **Leaf (Yaprak):** Ã‡ocuÄŸu olmayan node'lar
- **Height (YÃ¼kseklik):** Root'tan en derin yaprak'a kadar olan seviye sayÄ±sÄ±
- **Depth (Derinlik):** Bir node'un root'a olan uzaklÄ±ÄŸÄ±

### GÃ¶rsel Ã–rnek:
```
        A (Root, Depth=0)
       / \
      B   C (Depth=1)
     / \   \
    D   E   F (Depth=2, Leaves)
```

## Node YapÄ±sÄ± - C# Implementation

```csharp
// Binary Tree Node sÄ±nÄ±fÄ±
public class TreeNode
{
    public int Val { get; set; }
    public TreeNode Left { get; set; }    // Sol Ã§ocuk
    public TreeNode Right { get; set; }   // SaÄŸ Ã§ocuk
    
    public TreeNode(int val = 0)
    {
        Val = val;
        Left = null;
        Right = null;
    }
    
    // Helper method
    public bool IsLeaf => Left == null && Right == null;
}

// Generic version
public class TreeNode<T>
{
    public T Data { get; set; }
    public TreeNode<T> Left { get; set; }
    public TreeNode<T> Right { get; set; }
    
    public TreeNode(T data)
    {
        Data = data;
        Left = null;
        Right = null;
    }
}
```

## Temel Binary Tree Ä°ÅŸlemleri

### 1. Tree OluÅŸturma
```csharp
public class BinaryTree
{
    public TreeNode Root { get; set; }
    
    // Manuel tree oluÅŸturma
    public void CreateSampleTree()
    {
        Root = new TreeNode(1);
        Root.Left = new TreeNode(2);
        Root.Right = new TreeNode(3);
        Root.Left.Left = new TreeNode(4);
        Root.Left.Right = new TreeNode(5);
        
        //      1
        //     / \
        //    2   3
        //   / \
        //  4   5
    }
}
```

### 2. Tree'de Arama (Search)
```csharp
// Herhangi bir deÄŸeri ara - O(n)
public bool Search(TreeNode root, int target)
{
    if (root == null) return false;
    
    if (root.Val == target) return true;
    
    // Sol ve saÄŸ alt aÄŸaÃ§larda ara
    return Search(root.Left, target) || Search(root.Right, target);
}
```

### 3. Tree'nin YÃ¼ksekliÄŸini Bulma
```csharp
// Tree'nin height'ini hesapla - O(n)
public int GetHeight(TreeNode root)
{
    if (root == null) return -1; // BoÅŸ tree'nin height'i -1
    
    int leftHeight = GetHeight(root.Left);
    int rightHeight = GetHeight(root.Right);
    
    return Math.Max(leftHeight, rightHeight) + 1;
}
```

### 4. Node SayÄ±sÄ±nÄ± Sayma
```csharp
// Toplam node sayÄ±sÄ± - O(n)
public int CountNodes(TreeNode root)
{
    if (root == null) return 0;
    
    return 1 + CountNodes(root.Left) + CountNodes(root.Right);
}
```

### 5. Leaf Node'larÄ± Sayma
```csharp
// Yaprak node sayÄ±sÄ± - O(n)
public int CountLeaves(TreeNode root)
{
    if (root == null) return 0;
    
    if (root.IsLeaf) return 1;
    
    return CountLeaves(root.Left) + CountLeaves(root.Right);
}
```

## Binary Tree TÃ¼rleri

### 1. Full Binary Tree
Her node'un **0 veya 2 Ã§ocuÄŸu** var (1 Ã§ocuk yok):
```
      1
     / \
    2   3
   / \
  4   5
```

### 2. Complete Binary Tree
Son seviye hariÃ§ **tÃ¼m seviyeler dolu**, son seviye **soldan dolu**:
```
      1
     / \
    2   3
   / \ /
  4  5 6
```

### 3. Perfect Binary Tree
**TÃ¼m seviyeler tamamen dolu**:
```
      1
     / \
    2   3
   /|  |\ 
  4 5  6 7
```

### 4. Balanced Binary Tree
Her node iÃ§in **sol ve saÄŸ alt aÄŸaÃ§larÄ±n height farkÄ± â‰¤ 1**:
```csharp
// Balanced tree kontrolÃ¼
public bool IsBalanced(TreeNode root)
{
    if (root == null) return true;
    
    int leftHeight = GetHeight(root.Left);
    int rightHeight = GetHeight(root.Right);
    
    // Height farkÄ± 1'den fazla olmamalÄ±
    if (Math.Abs(leftHeight - rightHeight) > 1)
        return false;
    
    // Alt aÄŸaÃ§lar da balanced olmalÄ±
    return IsBalanced(root.Left) && IsBalanced(root.Right);
}
```

## Binary Tree'nin GerÃ§ek Hayat KullanÄ±mlarÄ±

### 1. Dosya Sistemi
```
    Root/
    /    \
  Users   System
  /  \      |
 Ali AyÅŸe  Logs
 |
Documents
```

### 2. Mathematical Expression Tree
```
Ifade: (2 + 3) * 4

      *
     / \
    +   4
   / \
  2   3
```

### 3. Decision Tree (Karar AÄŸacÄ±)
```csharp
public class DecisionTree
{
    public class DecisionNode
    {
        public string Question { get; set; }
        public DecisionNode YesChild { get; set; }
        public DecisionNode NoChild { get; set; }
        public string Result { get; set; } // Leaf node'lar iÃ§in
    }
    
    // Basit karar aÄŸacÄ± Ã¶rneÄŸi
    public DecisionNode BuildWeatherDecisionTree()
    {
        var root = new DecisionNode { Question = "Hava gÃ¼neÅŸli mi?" };
        
        root.YesChild = new DecisionNode { Question = "SÄ±cak mÄ±?" };
        root.YesChild.YesChild = new DecisionNode { Result = "Plaja git!" };
        root.YesChild.NoChild = new DecisionNode { Result = "Park'ta yÃ¼rÃ¼" };
        
        root.NoChild = new DecisionNode { Question = "YaÄŸmur yaÄŸÄ±yor mu?" };
        root.NoChild.YesChild = new DecisionNode { Result = "Evde kal" };
        root.NoChild.NoChild = new DecisionNode { Result = "Åemsiye al" };
        
        return root;
    }
}
```

## Binary Tree vs DiÄŸer Veri YapÄ±larÄ±

| Ã–zellik | Array | LinkedList | Binary Tree |
|---------|-------|------------|-------------|
| **Arama** | O(n) | O(n) | O(n) genel, O(log n) BST'de |
| **Ekleme** | O(n) | O(1) baÅŸa | O(log n) balanced'da |
| **Silme** | O(n) | O(n) | O(log n) balanced'da |
| **Hierarchical** | âŒ | âŒ | âœ… |
| **Sorted order** | Manuel | Manual | Otomatik (BST'de) |

## Binary Tree'nin AvantajlarÄ±

### âœ… GÃ¼Ã§lÃ¼ YanlarÄ±:
1. **Hierarchical structure:** Parent-child iliÅŸkileri doÄŸal
2. **Recursive algorithms:** Ã‡ok elegant Ã§Ã¶zÃ¼mler
3. **Efficient operations:** Balanced tree'lerde O(log n)
4. **Flexible:** BirÃ§ok probleme uyarlanabilir

### âŒ ZayÄ±f YanlarÄ±:
1. **Unbalanced tree risk:** Worst case O(n) olabilir
2. **Extra memory:** Pointer'lar iÃ§in ekstra yer
3. **No cache locality:** LinkedList gibi daÄŸÄ±nÄ±k bellek
4. **Complex implementation:** Array'den daha karmaÅŸÄ±k

## Ã–nemli Binary Tree Properties

### 1. Recursive Nature
Her binary tree, daha kÃ¼Ã§Ã¼k binary tree'lerin birleÅŸimi:
```csharp
// Recursive pattern
public void ProcessTree(TreeNode root)
{
    if (root == null) return; // Base case
    
    // Current node'u iÅŸle
    Console.WriteLine(root.Val);
    
    // Alt aÄŸaÃ§larÄ± recursive iÅŸle
    ProcessTree(root.Left);
    ProcessTree(root.Right);
}
```

### 2. Mathematical Properties
- **n node'lu complete binary tree'nin height'i:** âŒŠlogâ‚‚(n)âŒ‹
- **Height h'lÄ± perfect binary tree'deki node sayÄ±sÄ±:** 2^(h+1) - 1
- **n node'lu binary tree'nin maksimum height'i:** n-1 (degenerate case)

## Next Steps: Tree Traversal

Binary Tree'yi anladÄ±ÄŸÄ±nda **Tree Traversal** (aÄŸaÃ§ gezinme) teknikleri:
- **Preorder:** Root â†’ Left â†’ Right
- **Inorder:** Left â†’ Root â†’ Right  
- **Postorder:** Left â†’ Right â†’ Root
- **Level-order (BFS):** Seviye seviye

Bu traversal teknikleri, tree'deki tÃ¼m algoritmalarÄ±n temelini oluÅŸturur!

Binary Tree, computer science'Ä±n en fundamental kavramlarÄ±ndan biri. Ä°yi anlamak, BST, AVL Tree, Heap gibi geliÅŸmiÅŸ yapÄ±larÄ±n kapÄ±sÄ±nÄ± aÃ§ar! ğŸŒ³