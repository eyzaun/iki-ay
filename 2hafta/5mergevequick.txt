# Sorting Algorithms - MergeSort & QuickSort

## Neden Sıralama Bu Kadar Önemli?

Sıralama, computer science'ın **temel taşlarından** biri. Düşün ki kitaplığındaki binlerce kitabı **alfabetik sıraya** koyuyorsun - aradığın kitabı çok daha hızlı bulursun!

### Gerçek Hayattan Örnekler:
- **Google Search:** Milyarlarca web sayfası relevance'a göre sıralı
- **Netflix:** Filmler beğeni puanına göre sıralı  
- **E-commerce:** Ürünler fiyata/popülariteye göre sıralı
- **Database:** Index'ler sıralı tutuluyor

## Divide & Conquer Stratejisi

**MergeSort** ve **QuickSort** ikisi de **Divide & Conquer** tekniğini kullanır:

### Divide & Conquer Mantığı:
1. **Divide:** Problemi daha küçük parçalara böl
2. **Conquer:** Küçük parçaları çöz
3. **Combine:** Sonuçları birleştir

### Gerçek Hayat Örneği: Kargo Şirketi
Düşün ki 1000 paketi sıralaman gerek:
- **Naif yöntem:** Hepsini tek seferde sırala → Çok zor!
- **Akıllı yöntem:** 10 gruba böl (100'er paket), her grubu sırala, sonra birleştir → Kolay!

## MergeSort - "Böl ve Birleştir"

### MergeSort Mantığı:
Array'i **yarıya böl**, her yarıyı **recursive sırala**, sonra **sıralı birleştir**.

```
Örnek: [38, 27, 43, 3, 9, 82, 10]

1. Böl:     [38, 27, 43]    [3, 9, 82, 10]
2. Böl:   [38] [27, 43]   [3, 9] [82, 10]  
3. Böl:   [38] [27][43]   [3][9] [82][10]
4. Birleştir: [27, 43]     [3, 9] [10, 82]
5. Birleştir: [27, 38, 43] [3, 9, 10, 82]
6. Birleştir: [3, 9, 10, 27, 38, 43, 82]
```

### MergeSort Implementation:

```csharp
public class MergeSort
{
    // Ana MergeSort fonksiyonu
    public void Sort(int[] array)
    {
        if (array.Length <= 1) return;
        
        MergeSortHelper(array, 0, array.Length - 1);
    }
    
    // Recursive helper
    private void MergeSortHelper(int[] array, int left, int right)
    {
        if (left >= right) return; // Base case: 1 eleman
        
        int mid = left + (right - left) / 2; // Overflow'u önlemek için
        
        // Divide: Sol ve sağ yarıları sırala
        MergeSortHelper(array, left, mid);      // Sol yarı
        MergeSortHelper(array, mid + 1, right); // Sağ yarı
        
        // Conquer: Sıralı yarıları birleştir
        Merge(array, left, mid, right);
    }
    
    // İki sıralı yarıyı birleştir
    private void Merge(int[] array, int left, int mid, int right)
    {
        // Temporary arrays oluştur
        int leftSize = mid - left + 1;
        int rightSize = right - mid;
        
        int[] leftArray = new int[leftSize];
        int[] rightArray = new int[rightSize];
        
        // Data'yı temporary arrays'e kopyala
        Array.Copy(array, left, leftArray, 0, leftSize);
        Array.Copy(array, mid + 1, rightArray, 0, rightSize);
        
        // İki sıralı array'i birleştir
        int i = 0, j = 0, k = left;
        
        while (i < leftSize && j < rightSize)
        {
            if (leftArray[i] <= rightArray[j])
            {
                array[k] = leftArray[i];
                i++;
            }
            else
            {
                array[k] = rightArray[j];
                j++;
            }
            k++;
        }
        
        // Kalan elemanları ekle
        while (i < leftSize)
        {
            array[k] = leftArray[i];
            i++;
            k++;
        }
        
        while (j < rightSize)
        {
            array[k] = rightArray[j];
            j++;
            k++;
        }
    }
}
```

### MergeSort'un Özellikleri:

#### ✅ Avantajları:
- **Stable:** Eşit elemanların sırası korunur
- **Guaranteed O(n log n):** Worst case bile hızlı
- **Predictable:** Her zaman aynı performance
- **Good for large datasets:** Büyük veri setlerinde güvenilir

#### ❌ Dezavantajları:
- **Extra memory:** O(n) ekstra alan gerekir
- **Not in-place:** Original array'in yanında temporary arrays
- **Overhead:** Küçük arrays için gereksiz karmaşık

## QuickSort - "Pivot ve Böl"

### QuickSort Mantığı:
Bir **pivot** seç, pivot'tan küçükleri sol'a, büyükleri sağ'a koy, sonra **recursive** devam et.

```
Örnek: [10, 7, 8, 9, 1, 5]

1. Pivot = 5 seç
2. Partition: [1] [5] [10, 7, 8, 9]  (5'ten küçük sol, büyük sağ)
3. Sol: [1] → Sorted
4. Sağ: [10, 7, 8, 9] → Pivot = 9 → [7, 8] [9] [10]
5. Continue recursively...
```

### QuickSort Implementation:

```csharp
public class QuickSort
{
    // Ana QuickSort fonksiyonu
    public void Sort(int[] array)
    {
        if (array.Length <= 1) return;
        
        QuickSortHelper(array, 0, array.Length - 1);
    }
    
    // Recursive helper
    private void QuickSortHelper(int[] array, int low, int high)
    {
        if (low < high)
        {
            // Partition: pivot'ı doğru yerine koy
            int pivotIndex = Partition(array, low, high);
            
            // Divide: Pivot'ın sol ve sağını recursive sırala
            QuickSortHelper(array, low, pivotIndex - 1);  // Sol alt array
            QuickSortHelper(array, pivotIndex + 1, high); // Sağ alt array
        }
    }
    
    // Lomuto Partition Scheme
    private int Partition(int[] array, int low, int high)
    {
        int pivot = array[high]; // Son elemanı pivot olarak seç
        int i = low - 1;         // Küçük elemanların index'i
        
        for (int j = low; j < high; j++)
        {
            // Pivot'tan küçük veya eşitse
            if (array[j] <= pivot)
            {
                i++;
                Swap(array, i, j);
            }
        }
        
        // Pivot'ı doğru pozisyona koy
        Swap(array, i + 1, high);
        return i + 1; // Pivot'ın final pozisyonu
    }
    
    // Hoare Partition Scheme (Alternative)
    private int HoarePartition(int[] array, int low, int high)
    {
        int pivot = array[low]; // İlk elemanı pivot seç
        int i = low - 1;
        int j = high + 1;
        
        while (true)
        {
            // Sol'dan pivot'tan büyük bul
            do { i++; } while (array[i] < pivot);
            
            // Sağ'dan pivot'tan küçük bul  
            do { j--; } while (array[j] > pivot);
            
            if (i >= j) return j;
            
            Swap(array, i, j);
        }
    }
    
    private void Swap(int[] array, int i, int j)
    {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```

### QuickSort'un Özellikleri:

#### ✅ Avantajları:
- **In-place:** O(1) extra memory (recursion stack hariç)
- **Fast average case:** O(n log n) average performance
- **Cache efficient:** Locality of reference iyi
- **Simple implementation:** Anlaşılması kolay

#### ❌ Dezavantajları:
- **Worst case O(n²):** Pivot selection kötüyse
- **Not stable:** Eşit elemanların sırası değişebilir
- **Recursive depth:** Deep recursion stack overflow'a yol açabilir

## Pivot Selection Strategies

Pivot seçimi QuickSort'un **performansını kritik etkiler**:

### 1. First/Last Element
```csharp
int pivot = array[high]; // Simple ama risky
```

### 2. Random Pivot
```csharp
private int RandomPivot(int[] array, int low, int high)
{
    Random rand = new Random();
    int randomIndex = rand.Next(low, high + 1);
    Swap(array, randomIndex, high);
    return array[high];
}
```

### 3. Median-of-Three
```csharp
private int MedianOfThree(int[] array, int low, int high)
{
    int mid = low + (high - low) / 2;
    
    // Sort low, mid, high
    if (array[mid] < array[low])
        Swap(array, low, mid);
    if (array[high] < array[low])
        Swap(array, low, high);
    if (array[high] < array[mid])
        Swap(array, mid, high);
    
    // Median şimdi mid'de
    Swap(array, mid, high);
    return array[high];
}
```

## MergeSort vs QuickSort Karşılaştırması

| Özellik | MergeSort | QuickSort |
|---------|-----------|-----------|
| **Best Case** | O(n log n) | O(n log n) |
| **Average Case** | O(n log n) | O(n log n) |
| **Worst Case** | O(n log n) | **O(n²)** |
| **Space Complexity** | **O(n)** | O(log n) |
| **Stability** | **Stable** | Not stable |
| **In-place** | No | **Yes** |
| **Use Case** | Guaranteed performance | General purpose |

## Hibrit Sıralama: IntroSort

Gerçek dünyada **hibrit** yaklaşımlar kullanılır:

```csharp
public class IntroSort
{
    // .NET'in Array.Sort() benzeri hibrit yaklaşım
    public void Sort(int[] array)
    {
        IntroSortHelper(array, 0, array.Length - 1, 2 * FloorLog2(array.Length));
    }
    
    private void IntroSortHelper(int[] array, int low, int high, int depthLimit)
    {
        int size = high - low + 1;
        
        if (size <= 16)
        {
            // Küçük arrays için InsertionSort
            InsertionSort(array, low, high);
        }
        else if (depthLimit == 0)
        {
            // Çok derin recursion için HeapSort
            HeapSort(array, low, high);
        }
        else
        {
            // Normal durumda QuickSort
            int pivot = Partition(array, low, high);
            IntroSortHelper(array, low, pivot - 1, depthLimit - 1);
            IntroSortHelper(array, pivot + 1, high, depthLimit - 1);
        }
    }
    
    private void InsertionSort(int[] array, int low, int high)
    {
        // Small arrays için efficient
        for (int i = low + 1; i <= high; i++)
        {
            int key = array[i];
            int j = i - 1;
            
            while (j >= low && array[j] > key)
            {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }
    
    private int FloorLog2(int n)
    {
        return (int)Math.Floor(Math.Log2(n));
    }
}
```

## Pratik Kullanım Örnekleri

### 1. Custom Sorting
```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

// Custom comparison ile sorting
public void SortPeople(Person[] people)
{
    // Age'e göre sırala, eşitse Name'e göre
    Array.Sort(people, (p1, p2) =>
    {
        int ageComparison = p1.Age.CompareTo(p2.Age);
        return ageComparison != 0 ? ageComparison : p1.Name.CompareTo(p2.Name);
    });
}
```

### 2. Kth Largest Element (QuickSelect)
```csharp
// QuickSort'un modified versiyonu - average O(n)
public int FindKthLargest(int[] array, int k)
{
    return QuickSelect(array, 0, array.Length - 1, array.Length - k);
}

private int QuickSelect(int[] array, int low, int high, int targetIndex)
{
    if (low == high) return array[low];
    
    int pivotIndex = Partition(array, low, high);
    
    if (pivotIndex == targetIndex)
        return array[pivotIndex];
    else if (targetIndex < pivotIndex)
        return QuickSelect(array, low, pivotIndex - 1, targetIndex);
    else
        return QuickSelect(array, pivotIndex + 1, high, targetIndex);
}
```

## Sorting Algorithm Seçimi

### 🎯 Hangi Durumda Hangisini Kullan:

**MergeSort kullan eğer:**
- Stability önemliyse
- Guaranteed O(n log n) performance gerekiyorsa
- External sorting yapıyorsan (büyük dosyalar)
- Linked list sorting yapıyorsan

**QuickSort kullan eğer:**
- Memory sınırlıysa
- Average case performance yeterliyse
- In-place sorting gerekiyorsa
- General purpose sorting yapıyorsan

**Hibrit approach kullan eğer:**
- Production code yazıyorsan
- En iyi overall performance istiyorsan
- Different input sizes handle edeceksen

Next: Binary Search - Advanced searching techniques! 🔍