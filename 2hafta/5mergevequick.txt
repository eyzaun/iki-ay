# Sorting Algorithms - MergeSort & QuickSort

## Neden SÄ±ralama Bu Kadar Ã–nemli?

SÄ±ralama, computer science'Ä±n **temel taÅŸlarÄ±ndan** biri. DÃ¼ÅŸÃ¼n ki kitaplÄ±ÄŸÄ±ndaki binlerce kitabÄ± **alfabetik sÄ±raya** koyuyorsun - aradÄ±ÄŸÄ±n kitabÄ± Ã§ok daha hÄ±zlÄ± bulursun!

### GerÃ§ek Hayattan Ã–rnekler:
- **Google Search:** Milyarlarca web sayfasÄ± relevance'a gÃ¶re sÄ±ralÄ±
- **Netflix:** Filmler beÄŸeni puanÄ±na gÃ¶re sÄ±ralÄ±  
- **E-commerce:** ÃœrÃ¼nler fiyata/popÃ¼lariteye gÃ¶re sÄ±ralÄ±
- **Database:** Index'ler sÄ±ralÄ± tutuluyor

## Divide & Conquer Stratejisi

**MergeSort** ve **QuickSort** ikisi de **Divide & Conquer** tekniÄŸini kullanÄ±r:

### Divide & Conquer MantÄ±ÄŸÄ±:
1. **Divide:** Problemi daha kÃ¼Ã§Ã¼k parÃ§alara bÃ¶l
2. **Conquer:** KÃ¼Ã§Ã¼k parÃ§alarÄ± Ã§Ã¶z
3. **Combine:** SonuÃ§larÄ± birleÅŸtir

### GerÃ§ek Hayat Ã–rneÄŸi: Kargo Åirketi
DÃ¼ÅŸÃ¼n ki 1000 paketi sÄ±ralaman gerek:
- **Naif yÃ¶ntem:** Hepsini tek seferde sÄ±rala â†’ Ã‡ok zor!
- **AkÄ±llÄ± yÃ¶ntem:** 10 gruba bÃ¶l (100'er paket), her grubu sÄ±rala, sonra birleÅŸtir â†’ Kolay!

## MergeSort - "BÃ¶l ve BirleÅŸtir"

### MergeSort MantÄ±ÄŸÄ±:
Array'i **yarÄ±ya bÃ¶l**, her yarÄ±yÄ± **recursive sÄ±rala**, sonra **sÄ±ralÄ± birleÅŸtir**.

```
Ã–rnek: [38, 27, 43, 3, 9, 82, 10]

1. BÃ¶l:     [38, 27, 43]    [3, 9, 82, 10]
2. BÃ¶l:   [38] [27, 43]   [3, 9] [82, 10]  
3. BÃ¶l:   [38] [27][43]   [3][9] [82][10]
4. BirleÅŸtir: [27, 43]     [3, 9] [10, 82]
5. BirleÅŸtir: [27, 38, 43] [3, 9, 10, 82]
6. BirleÅŸtir: [3, 9, 10, 27, 38, 43, 82]
```

### MergeSort Implementation:

```csharp
public class MergeSort
{
    // Ana MergeSort fonksiyonu
    public void Sort(int[] array)
    {
        if (array.Length <= 1) return;
        
        MergeSortHelper(array, 0, array.Length - 1);
    }
    
    // Recursive helper
    private void MergeSortHelper(int[] array, int left, int right)
    {
        if (left >= right) return; // Base case: 1 eleman
        
        int mid = left + (right - left) / 2; // Overflow'u Ã¶nlemek iÃ§in
        
        // Divide: Sol ve saÄŸ yarÄ±larÄ± sÄ±rala
        MergeSortHelper(array, left, mid);      // Sol yarÄ±
        MergeSortHelper(array, mid + 1, right); // SaÄŸ yarÄ±
        
        // Conquer: SÄ±ralÄ± yarÄ±larÄ± birleÅŸtir
        Merge(array, left, mid, right);
    }
    
    // Ä°ki sÄ±ralÄ± yarÄ±yÄ± birleÅŸtir
    private void Merge(int[] array, int left, int mid, int right)
    {
        // Temporary arrays oluÅŸtur
        int leftSize = mid - left + 1;
        int rightSize = right - mid;
        
        int[] leftArray = new int[leftSize];
        int[] rightArray = new int[rightSize];
        
        // Data'yÄ± temporary arrays'e kopyala
        Array.Copy(array, left, leftArray, 0, leftSize);
        Array.Copy(array, mid + 1, rightArray, 0, rightSize);
        
        // Ä°ki sÄ±ralÄ± array'i birleÅŸtir
        int i = 0, j = 0, k = left;
        
        while (i < leftSize && j < rightSize)
        {
            if (leftArray[i] <= rightArray[j])
            {
                array[k] = leftArray[i];
                i++;
            }
            else
            {
                array[k] = rightArray[j];
                j++;
            }
            k++;
        }
        
        // Kalan elemanlarÄ± ekle
        while (i < leftSize)
        {
            array[k] = leftArray[i];
            i++;
            k++;
        }
        
        while (j < rightSize)
        {
            array[k] = rightArray[j];
            j++;
            k++;
        }
    }
}
```

### MergeSort'un Ã–zellikleri:

#### âœ… AvantajlarÄ±:
- **Stable:** EÅŸit elemanlarÄ±n sÄ±rasÄ± korunur
- **Guaranteed O(n log n):** Worst case bile hÄ±zlÄ±
- **Predictable:** Her zaman aynÄ± performance
- **Good for large datasets:** BÃ¼yÃ¼k veri setlerinde gÃ¼venilir

#### âŒ DezavantajlarÄ±:
- **Extra memory:** O(n) ekstra alan gerekir
- **Not in-place:** Original array'in yanÄ±nda temporary arrays
- **Overhead:** KÃ¼Ã§Ã¼k arrays iÃ§in gereksiz karmaÅŸÄ±k

## QuickSort - "Pivot ve BÃ¶l"

### QuickSort MantÄ±ÄŸÄ±:
Bir **pivot** seÃ§, pivot'tan kÃ¼Ã§Ã¼kleri sol'a, bÃ¼yÃ¼kleri saÄŸ'a koy, sonra **recursive** devam et.

```
Ã–rnek: [10, 7, 8, 9, 1, 5]

1. Pivot = 5 seÃ§
2. Partition: [1] [5] [10, 7, 8, 9]  (5'ten kÃ¼Ã§Ã¼k sol, bÃ¼yÃ¼k saÄŸ)
3. Sol: [1] â†’ Sorted
4. SaÄŸ: [10, 7, 8, 9] â†’ Pivot = 9 â†’ [7, 8] [9] [10]
5. Continue recursively...
```

### QuickSort Implementation:

```csharp
public class QuickSort
{
    // Ana QuickSort fonksiyonu
    public void Sort(int[] array)
    {
        if (array.Length <= 1) return;
        
        QuickSortHelper(array, 0, array.Length - 1);
    }
    
    // Recursive helper
    private void QuickSortHelper(int[] array, int low, int high)
    {
        if (low < high)
        {
            // Partition: pivot'Ä± doÄŸru yerine koy
            int pivotIndex = Partition(array, low, high);
            
            // Divide: Pivot'Ä±n sol ve saÄŸÄ±nÄ± recursive sÄ±rala
            QuickSortHelper(array, low, pivotIndex - 1);  // Sol alt array
            QuickSortHelper(array, pivotIndex + 1, high); // SaÄŸ alt array
        }
    }
    
    // Lomuto Partition Scheme
    private int Partition(int[] array, int low, int high)
    {
        int pivot = array[high]; // Son elemanÄ± pivot olarak seÃ§
        int i = low - 1;         // KÃ¼Ã§Ã¼k elemanlarÄ±n index'i
        
        for (int j = low; j < high; j++)
        {
            // Pivot'tan kÃ¼Ã§Ã¼k veya eÅŸitse
            if (array[j] <= pivot)
            {
                i++;
                Swap(array, i, j);
            }
        }
        
        // Pivot'Ä± doÄŸru pozisyona koy
        Swap(array, i + 1, high);
        return i + 1; // Pivot'Ä±n final pozisyonu
    }
    
    // Hoare Partition Scheme (Alternative)
    private int HoarePartition(int[] array, int low, int high)
    {
        int pivot = array[low]; // Ä°lk elemanÄ± pivot seÃ§
        int i = low - 1;
        int j = high + 1;
        
        while (true)
        {
            // Sol'dan pivot'tan bÃ¼yÃ¼k bul
            do { i++; } while (array[i] < pivot);
            
            // SaÄŸ'dan pivot'tan kÃ¼Ã§Ã¼k bul  
            do { j--; } while (array[j] > pivot);
            
            if (i >= j) return j;
            
            Swap(array, i, j);
        }
    }
    
    private void Swap(int[] array, int i, int j)
    {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```

### QuickSort'un Ã–zellikleri:

#### âœ… AvantajlarÄ±:
- **In-place:** O(1) extra memory (recursion stack hariÃ§)
- **Fast average case:** O(n log n) average performance
- **Cache efficient:** Locality of reference iyi
- **Simple implementation:** AnlaÅŸÄ±lmasÄ± kolay

#### âŒ DezavantajlarÄ±:
- **Worst case O(nÂ²):** Pivot selection kÃ¶tÃ¼yse
- **Not stable:** EÅŸit elemanlarÄ±n sÄ±rasÄ± deÄŸiÅŸebilir
- **Recursive depth:** Deep recursion stack overflow'a yol aÃ§abilir

## Pivot Selection Strategies

Pivot seÃ§imi QuickSort'un **performansÄ±nÄ± kritik etkiler**:

### 1. First/Last Element
```csharp
int pivot = array[high]; // Simple ama risky
```

### 2. Random Pivot
```csharp
private int RandomPivot(int[] array, int low, int high)
{
    Random rand = new Random();
    int randomIndex = rand.Next(low, high + 1);
    Swap(array, randomIndex, high);
    return array[high];
}
```

### 3. Median-of-Three
```csharp
private int MedianOfThree(int[] array, int low, int high)
{
    int mid = low + (high - low) / 2;
    
    // Sort low, mid, high
    if (array[mid] < array[low])
        Swap(array, low, mid);
    if (array[high] < array[low])
        Swap(array, low, high);
    if (array[high] < array[mid])
        Swap(array, mid, high);
    
    // Median ÅŸimdi mid'de
    Swap(array, mid, high);
    return array[high];
}
```

## MergeSort vs QuickSort KarÅŸÄ±laÅŸtÄ±rmasÄ±

| Ã–zellik | MergeSort | QuickSort |
|---------|-----------|-----------|
| **Best Case** | O(n log n) | O(n log n) |
| **Average Case** | O(n log n) | O(n log n) |
| **Worst Case** | O(n log n) | **O(nÂ²)** |
| **Space Complexity** | **O(n)** | O(log n) |
| **Stability** | **Stable** | Not stable |
| **In-place** | No | **Yes** |
| **Use Case** | Guaranteed performance | General purpose |

## Hibrit SÄ±ralama: IntroSort

GerÃ§ek dÃ¼nyada **hibrit** yaklaÅŸÄ±mlar kullanÄ±lÄ±r:

```csharp
public class IntroSort
{
    // .NET'in Array.Sort() benzeri hibrit yaklaÅŸÄ±m
    public void Sort(int[] array)
    {
        IntroSortHelper(array, 0, array.Length - 1, 2 * FloorLog2(array.Length));
    }
    
    private void IntroSortHelper(int[] array, int low, int high, int depthLimit)
    {
        int size = high - low + 1;
        
        if (size <= 16)
        {
            // KÃ¼Ã§Ã¼k arrays iÃ§in InsertionSort
            InsertionSort(array, low, high);
        }
        else if (depthLimit == 0)
        {
            // Ã‡ok derin recursion iÃ§in HeapSort
            HeapSort(array, low, high);
        }
        else
        {
            // Normal durumda QuickSort
            int pivot = Partition(array, low, high);
            IntroSortHelper(array, low, pivot - 1, depthLimit - 1);
            IntroSortHelper(array, pivot + 1, high, depthLimit - 1);
        }
    }
    
    private void InsertionSort(int[] array, int low, int high)
    {
        // Small arrays iÃ§in efficient
        for (int i = low + 1; i <= high; i++)
        {
            int key = array[i];
            int j = i - 1;
            
            while (j >= low && array[j] > key)
            {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }
    
    private int FloorLog2(int n)
    {
        return (int)Math.Floor(Math.Log2(n));
    }
}
```

## Pratik KullanÄ±m Ã–rnekleri

### 1. Custom Sorting
```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

// Custom comparison ile sorting
public void SortPeople(Person[] people)
{
    // Age'e gÃ¶re sÄ±rala, eÅŸitse Name'e gÃ¶re
    Array.Sort(people, (p1, p2) =>
    {
        int ageComparison = p1.Age.CompareTo(p2.Age);
        return ageComparison != 0 ? ageComparison : p1.Name.CompareTo(p2.Name);
    });
}
```

### 2. Kth Largest Element (QuickSelect)
```csharp
// QuickSort'un modified versiyonu - average O(n)
public int FindKthLargest(int[] array, int k)
{
    return QuickSelect(array, 0, array.Length - 1, array.Length - k);
}

private int QuickSelect(int[] array, int low, int high, int targetIndex)
{
    if (low == high) return array[low];
    
    int pivotIndex = Partition(array, low, high);
    
    if (pivotIndex == targetIndex)
        return array[pivotIndex];
    else if (targetIndex < pivotIndex)
        return QuickSelect(array, low, pivotIndex - 1, targetIndex);
    else
        return QuickSelect(array, pivotIndex + 1, high, targetIndex);
}
```

## Sorting Algorithm SeÃ§imi

### ğŸ¯ Hangi Durumda Hangisini Kullan:

**MergeSort kullan eÄŸer:**
- Stability Ã¶nemliyse
- Guaranteed O(n log n) performance gerekiyorsa
- External sorting yapÄ±yorsan (bÃ¼yÃ¼k dosyalar)
- Linked list sorting yapÄ±yorsan

**QuickSort kullan eÄŸer:**
- Memory sÄ±nÄ±rlÄ±ysa
- Average case performance yeterliyse
- In-place sorting gerekiyorsa
- General purpose sorting yapÄ±yorsan

**Hibrit approach kullan eÄŸer:**
- Production code yazÄ±yorsan
- En iyi overall performance istiyorsan
- Different input sizes handle edeceksen

Next: Binary Search - Advanced searching techniques! ğŸ”