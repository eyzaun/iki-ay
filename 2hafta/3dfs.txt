# Tree Traversal - DFS (Depth-First Search)

## Tree Traversal Nedir? Neden Bu Kadar Ã–nemli?

Tree Traversal, **aÄŸaÃ§taki her node'u sistematik olarak ziyaret etme** yÃ¶ntemidir. TÄ±pkÄ± bir mÃ¼zeyi gezmek gibi - hangi sÄ±rayla hangi salonu ziyaret edeceÄŸine karar vermelisin.

### GerÃ§ek Hayattan Benzetme: Ev TemizliÄŸi
DÃ¼ÅŸÃ¼n ki 3 katlÄ± bir evi temizliyorsun:
- **DFS (Depth-First):** Bir odaya gir, o odanÄ±n tÃ¼m dolap/Ã§ekmecelerini bitir, sonra diÄŸer odaya geÃ§
- **BFS (Breadth-First):** TÃ¼m odalarÄ± yÃ¼zeysel temizle, sonra derinlemesine git

## DFS'in 3 TÃ¼rÃ¼

DFS'te **Root, Left, Right** sÄ±ralamasÄ± Ã¶nemli:

### 1. **Preorder:** Root â†’ Left â†’ Right
### 2. **Inorder:** Left â†’ Root â†’ Right  
### 3. **Postorder:** Left â†’ Right â†’ Root

### GÃ¶rsel Ã–rnek:
```
Tree:
       1
      / \
     2   3
    / \
   4   5

Preorder:  1, 2, 4, 5, 3  (Root Ã¶nce)
Inorder:   4, 2, 5, 1, 3  (Root ortada)
Postorder: 4, 5, 2, 3, 1  (Root sonra)
```

## 1. Preorder Traversal (Root â†’ Left â†’ Right)

**Ne zaman kullanÄ±lÄ±r:** Tree'yi **kopyalamak**, **serialize etmek** iÃ§in.

```csharp
// Preorder: Root iÅŸle, sonra sol, sonra saÄŸ
public void PreorderTraversal(TreeNode root, List<int> result)
{
    if (root == null) return;
    
    result.Add(root.Val);               // Root'u iÅŸle (1. adÄ±m)
    PreorderTraversal(root.Left, result);  // Sol alt aÄŸaÃ§ (2. adÄ±m)
    PreorderTraversal(root.Right, result); // SaÄŸ alt aÄŸaÃ§ (3. adÄ±m)
}

// Iterative version (Stack kullanarak)
public List<int> PreorderIterative(TreeNode root)
{
    List<int> result = new List<int>();
    if (root == null) return result;
    
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.Push(root);
    
    while (stack.Count > 0)
    {
        TreeNode current = stack.Pop();
        result.Add(current.Val);        // Root'u iÅŸle
        
        // SaÄŸ Ã§ocuÄŸu Ã¶nce push et (sonra iÅŸlenmesi iÃ§in)
        if (current.Right != null)
            stack.Push(current.Right);
        
        // Sol Ã§ocuÄŸu sonra push et (Ã¶nce iÅŸlenmesi iÃ§in)
        if (current.Left != null)
            stack.Push(current.Left);
    }
    
    return result;
}
```

### Preorder KullanÄ±m AlanlarÄ±:
```csharp
// 1. Tree'yi serialize etme (string'e Ã§evirme)
public string SerializeTree(TreeNode root)
{
    if (root == null) return "null";
    
    return root.Val + "," + 
           SerializeTree(root.Left) + "," + 
           SerializeTree(root.Right);
}

// 2. Directory structure yazdÄ±rma
public void PrintDirectoryStructure(TreeNode root, int depth = 0)
{
    if (root == null) return;
    
    // Current directory'yi yazdÄ±r (Root)
    string indent = new string(' ', depth * 2);
    Console.WriteLine($"{indent}{root.Val}");
    
    // Alt directory'leri yazdÄ±r (Left, Right)
    PrintDirectoryStructure(root.Left, depth + 1);
    PrintDirectoryStructure(root.Right, depth + 1);
}
```

## 2. Inorder Traversal (Left â†’ Root â†’ Right)

**Ne zaman kullanÄ±lÄ±r:** **BST'de sorted order** elde etmek iÃ§in!

```csharp
// Inorder: Sol, Root iÅŸle, saÄŸ
public void InorderTraversal(TreeNode root, List<int> result)
{
    if (root == null) return;
    
    InorderTraversal(root.Left, result);   // Sol alt aÄŸaÃ§ (1. adÄ±m)
    result.Add(root.Val);                  // Root'u iÅŸle (2. adÄ±m)
    InorderTraversal(root.Right, result);  // SaÄŸ alt aÄŸaÃ§ (3. adÄ±m)
}

// Iterative version
public List<int> InorderIterative(TreeNode root)
{
    List<int> result = new List<int>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode current = root;
    
    while (current != null || stack.Count > 0)
    {
        // En sol node'a kadar git
        while (current != null)
        {
            stack.Push(current);
            current = current.Left;
        }
        
        // Stack'ten al ve iÅŸle
        current = stack.Pop();
        result.Add(current.Val);
        
        // SaÄŸ alt aÄŸaca geÃ§
        current = current.Right;
    }
    
    return result;
}
```

### Inorder'Ä±n Sihirli GÃ¼cÃ¼ - BST'de Sorted Order:
```csharp
// BST'deki elemanlarÄ± sÄ±ralÄ± ÅŸekilde al
public List<int> GetSortedElementsFromBST(TreeNode root)
{
    List<int> result = new List<int>();
    InorderTraversal(root, result);
    return result; // Otomatik olarak sÄ±ralÄ±! ğŸ¯
}

// BST'de k'Ä±ncÄ± smallest element
public int KthSmallest(TreeNode root, int k)
{
    int count = 0;
    return KthSmallestHelper(root, k, ref count);
}

private int KthSmallestHelper(TreeNode root, int k, ref int count)
{
    if (root == null) return -1;
    
    // Sol (smaller elements)
    int leftResult = KthSmallestHelper(root.Left, k, ref count);
    if (leftResult != -1) return leftResult;
    
    // Root
    count++;
    if (count == k) return root.Val;
    
    // SaÄŸ (larger elements)
    return KthSmallestHelper(root.Right, k, ref count);
}
```

## 3. Postorder Traversal (Left â†’ Right â†’ Root)

**Ne zaman kullanÄ±lÄ±r:** **Tree'yi silmek**, **alt aÄŸaÃ§larÄ±n sonucunu birleÅŸtirmek** iÃ§in.

```csharp
// Postorder: Sol, saÄŸ, Root iÅŸle
public void PostorderTraversal(TreeNode root, List<int> result)
{
    if (root == null) return;
    
    PostorderTraversal(root.Left, result);  // Sol alt aÄŸaÃ§ (1. adÄ±m)
    PostorderTraversal(root.Right, result); // SaÄŸ alt aÄŸaÃ§ (2. adÄ±m)
    result.Add(root.Val);                   // Root'u iÅŸle (3. adÄ±m)
}

// Iterative version (2 stack kullanarak)
public List<int> PostorderIterative(TreeNode root)
{
    List<int> result = new List<int>();
    if (root == null) return result;
    
    Stack<TreeNode> stack1 = new Stack<TreeNode>();
    Stack<TreeNode> stack2 = new Stack<TreeNode>();
    
    stack1.Push(root);
    
    while (stack1.Count > 0)
    {
        TreeNode current = stack1.Pop();
        stack2.Push(current);
        
        if (current.Left != null)
            stack1.Push(current.Left);
        if (current.Right != null)
            stack1.Push(current.Right);
    }
    
    while (stack2.Count > 0)
    {
        result.Add(stack2.Pop().Val);
    }
    
    return result;
}
```

### Postorder KullanÄ±m AlanlarÄ±:
```csharp
// 1. Tree'yi silme (alt aÄŸaÃ§larÄ± Ã¶nce sil)
public void DeleteTree(TreeNode root)
{
    if (root == null) return;
    
    DeleteTree(root.Left);   // Sol alt aÄŸacÄ± sil
    DeleteTree(root.Right);  // SaÄŸ alt aÄŸacÄ± sil
    
    // Åimdi current node'u gÃ¼venle sil
    Console.WriteLine($"Silinen node: {root.Val}");
    root = null;
}

// 2. Directory size hesaplama
public int CalculateDirectorySize(TreeNode root)
{
    if (root == null) return 0;
    
    int leftSize = CalculateDirectorySize(root.Left);   // Sol klasÃ¶r boyutu
    int rightSize = CalculateDirectorySize(root.Right); // SaÄŸ klasÃ¶r boyutu
    
    return root.Val + leftSize + rightSize; // Total boyut
}

// 3. Tree height hesaplama
public int CalculateHeight(TreeNode root)
{
    if (root == null) return -1;
    
    int leftHeight = CalculateHeight(root.Left);
    int rightHeight = CalculateHeight(root.Right);
    
    return Math.Max(leftHeight, rightHeight) + 1;
}
```

## DFS Traversal'larÄ±n KarÅŸÄ±laÅŸtÄ±rmasÄ±

```csharp
public class TraversalDemo
{
    public void DemonstrateTraversals()
    {
        // Sample tree oluÅŸtur:
        //       1
        //      / \
        //     2   3
        //    / \
        //   4   5
        
        TreeNode root = new TreeNode(1);
        root.Left = new TreeNode(2);
        root.Right = new TreeNode(3);
        root.Left.Left = new TreeNode(4);
        root.Left.Right = new TreeNode(5);
        
        List<int> preorder = new List<int>();
        List<int> inorder = new List<int>();
        List<int> postorder = new List<int>();
        
        PreorderTraversal(root, preorder);
        InorderTraversal(root, inorder);
        PostorderTraversal(root, postorder);
        
        Console.WriteLine($"Preorder:  {string.Join(", ", preorder)}");  // 1, 2, 4, 5, 3
        Console.WriteLine($"Inorder:   {string.Join(", ", inorder)}");   // 4, 2, 5, 1, 3
        Console.WriteLine($"Postorder: {string.Join(", ", postorder)}"); // 4, 5, 2, 3, 1
    }
}
```

## Traversal ile Problem Ã‡Ã¶zme Ã–rnekleri

### 1. Tree'deki Maximum Path Sum
```csharp
public int MaxPathSum(TreeNode root)
{
    int maxSum = int.MinValue;
    MaxPathSumHelper(root, ref maxSum);
    return maxSum;
}

private int MaxPathSumHelper(TreeNode root, ref int maxSum)
{
    if (root == null) return 0;
    
    // Alt aÄŸaÃ§lardan maksimum contribution'Ä± al (negatifse 0)
    int leftMax = Math.Max(0, MaxPathSumHelper(root.Left, ref maxSum));
    int rightMax = Math.Max(0, MaxPathSumHelper(root.Right, ref maxSum));
    
    // Current node'dan geÃ§en maksimum path
    int currentPathSum = root.Val + leftMax + rightMax;
    maxSum = Math.Max(maxSum, currentPathSum);
    
    // Parent'a dÃ¶ndÃ¼rÃ¼lecek maksimum (tek taraf)
    return root.Val + Math.Max(leftMax, rightMax);
}
```

### 2. Tree'yi Mirror Etme
```csharp
public TreeNode MirrorTree(TreeNode root)
{
    if (root == null) return null;
    
    // Alt aÄŸaÃ§larÄ± mirror et
    TreeNode leftMirror = MirrorTree(root.Left);
    TreeNode rightMirror = MirrorTree(root.Right);
    
    // Sol ve saÄŸÄ± yer deÄŸiÅŸtir
    root.Left = rightMirror;
    root.Right = leftMirror;
    
    return root;
}
```

### 3. Same Tree KontrolÃ¼
```csharp
public bool IsSameTree(TreeNode p, TreeNode q)
{
    // Base cases
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;
    
    // Current node'larÄ± karÅŸÄ±laÅŸtÄ±r
    if (p.Val != q.Val) return false;
    
    // Alt aÄŸaÃ§larÄ± recursive kontrol et
    return IsSameTree(p.Left, q.Left) && IsSameTree(p.Right, q.Right);
}
```

## DFS'in Complexity Analizi

### Time Complexity: **O(n)**
- Her node'u tam olarak 1 kez ziyaret ederiz
- n = toplam node sayÄ±sÄ±

### Space Complexity: **O(h)**
- Recursion call stack'i tree height'i kadar
- h = tree height
- **Best case (balanced):** O(log n)
- **Worst case (degenerate):** O(n)

## DFS Ne Zaman KullanÄ±lÄ±r?

### âœ… DFS Kullan EÄŸer:
- **Tree structure'Ä± iÅŸliyorsan**
- **Path-based** problemler Ã§Ã¶zÃ¼yorsan
- **Bottom-up** hesaplama gerekiyorsa (postorder)
- **Memory efficient** solution lazÄ±msa
- **Recursive** nature'Ä± varsa

### ğŸ¯ Hangi DFS TÃ¼rÃ¼nÃ¼ SeÃ§:
- **Preorder:** Tree copying, serialization
- **Inorder:** BST'de sorted order, validation
- **Postorder:** Tree deletion, size calculation, bottom-up computations

Next: BFS (Breadth-First Search) - Level-order traversal! ğŸŒŠ